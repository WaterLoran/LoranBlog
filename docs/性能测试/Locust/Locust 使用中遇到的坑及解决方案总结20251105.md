## Locust 使用中遇到的坑及解决方案总结20251105

### 1. **请求成功判断的坑**
**问题**：手动调用 `response.success()` 时出现错误
```
Tried to set status on a request that has not yet been made.
```

**原因**：没有正确使用 `with` 语句块

**解决方案**：
```python
# ❌ 错误写法
rsp = self.client.request(method=method, url=url, catch_response=True)
if rsp.status_code == 200:
    rsp.success()

# ✅ 正确写法
with self.client.request(method=method, url=url, catch_response=True) as rsp:
    if rsp.status_code == 200:
        rsp.success()
```

### 2. **Charts 图表不显示数据**
**问题**：在 Web 界面的 Charts 标签页看不到数据，但 Statistics 有数据

**原因**：
- 请求频率太低，数据点不足
- 统计历史记录未正确启用
- 浏览器缓存问题

**解决方案**：
```python
# 确保启用统计历史
@events.init.add_listener
def setup_charts(environment, **_kwargs):
    environment.stats_history_enabled = True
    
# 增加请求频率
wait_time = between(0.1, 0.5)  # 高频率请求
```

### 3. **Statistics 只显示部分接口**
**问题**：统计页面只显示 3-5 个接口，实际有更多接口需要监控

**原因**：Locust 默认只显示请求最多的几个接口

**解决方案**：
```python
# 禁用分组，显示所有独立端点
@events.init.add_listener
def setup_stats(environment, **_kwargs):
    environment.stats.enable_grouping = False  # 关键配置
    
# 为每个端点使用唯一名称
self.client.get("/api/users", name="Users_GetAll")
self.client.post("/api/users", name="Users_Create")
```

### 4. **多域名请求处理**
**问题**：一个 task 中需要请求多个不同域名的 API

**解决方案**：
```python
# 方法1：直接使用完整URL
self.client.get("https://api1.com/endpoint")
self.client.post("https://api2.com/endpoint", json=data)

# 方法2：创建多个HttpSession
self.api1_client = HttpSession(base_url="https://api1.com")
self.api2_client = HttpSession(base_url="https://api2.com")
```

### 5. **请求依赖关系处理**
**问题**：多个请求之间有数据依赖关系，需要顺序执行

**解决方案**：
```python
@task
def dependent_workflow(self):
    # 第一步：获取数据
    with self.client.get("/auth/token", catch_response=True) as rsp:
        if rsp.status_code == 200:
            token = rsp.json().get("token")
            rsp.success()
        else:
            rsp.failure("Get token failed")
            return  # 失败则停止后续
    
    # 第二步：使用上一步的数据
    with self.client.post("/api/data", 
                         headers={"Authorization": f"Bearer {token}"},
                         catch_response=True) as rsp:
        if rsp.status_code == 201:
            rsp.success()
```

### 6. **任务组织结构混乱**
**问题**：多个任务之间逻辑关系不清晰

**解决方案**：
```python
# 使用 TaskSet 按业务域组织
class AuthTasks(TaskSet):
    @task
    def login(self): pass
    
    @task  
    def logout(self): pass

class OrderTasks(TaskSet):
    @task
    def create_order(self): pass
    
    @task
    def get_orders(self): pass

class MainUser(HttpUser):
    tasks = [AuthTasks, OrderTasks]  # 清晰的组织结构
```

### 7. **配置属性设置错误**
**问题**：尝试设置只读属性导致错误
```
AttributeError: can't set attribute
```

**原因**：在 Locust 2.x 中某些属性是只读的

**解决方案**：
```python
# ❌ 错误配置
environment.stats.num_requests = 50  # 这是只读属性

# ✅ 正确配置
environment.stats.enable_grouping = False  # 可配置的属性
environment.stats_history_size = 100
```

### 8. **动态参数和上下文传递**
**问题**：需要在任务间传递数据

**解决方案**：
```python
def on_start(self):
    self.context = {}  # 初始化上下文

@task
def workflow(self):
    # 第一步：获取数据并保存到上下文
    with self.client.get("/data", catch_response=True) as rsp:
        if rsp.ok:
            self.context['data_id'] = rsp.json().get('id')
            rsp.success()
    
    # 第二步：使用上下文数据
    if 'data_id' in self.context:
        self.client.get(f"/data/{self.context['data_id']}")
```

### 9. **请求名称管理**
**问题**：统计中请求名称混乱，难以区分

**解决方案**：
```python
# 使用有意义的命名规范
self.client.get("/api/v1/users", name="API_GetUsers")
self.client.post("/api/v1/users", name="API_CreateUser")
self.client.get("/api/v1/orders", name="API_GetOrders")

# 或者使用编号
self.client.get("/endpoint1", name="01_GetEndpoint1")
self.client.post("/endpoint2", name="02_PostEndpoint2")
```

### 10. **测试停止和监控**
**问题**：不知道如何正确停止测试和监控状态

**解决方案**：
- **停止测试**：Web 界面点击红色 "STOP" 按钮
- **命令行停止**：`Ctrl + C`
- **监控状态**：使用事件监听器
```python
@events.request.add_listener
def on_request(request_type, name, response_time, **kwargs):
    print(f"Request: {name}, Time: {response_time}ms")
```

## 最佳实践总结

1. **始终使用 `with` 语句** 当使用 `catch_response=True`
2. **为每个端点使用唯一名称** 确保独立统计
3. **禁用分组** 以显示所有接口：`environment.stats.enable_grouping = False`
4. **组织任务结构** 使用 TaskSet 按业务域分离
5. **处理依赖关系** 通过上下文变量传递数据
6. **监控统计条目** 定期检查是否所有端点都被跟踪
7. **使用事件监听器** 进行调试和监控

这些经验总结应该能帮助你避免常见的 Locust 使用陷阱，编写出更稳定、可维护的性能测试脚本。
确定性能问题是否由 GC（垃圾回收）引起，并给出一些参考标准，可以按照以下步骤系统性地进行：

### 1. **收集 GC 日志**
要分析 GC 的行为，首先确保 Java 应用启动时启用了 GC 日志记录。你可以通过添加 JVM 启动参数来启用 GC 日志，具体如下：

- **Java 8**:
  ```sh
  -Xloggc:gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime
  ```
- **Java 9 及以上版本**:
  ```sh
  -Xlog:gc*:file=gc.log:time,uptime,level,tags
  ```

### 2. **分析 GC 日志的关键指标**
分析 GC 日志来判断 GC 是否引起了性能问题，主要关注以下几个关键指标：

#### 2.1 **GC 频率**
- **Minor GC 频率**：Minor GC 通常发生在新生代满了之后。如果 Minor GC 非常频繁（每隔几秒甚至几百毫秒发生一次），则可能影响应用程序性能。
- **Full GC 频率**：Full GC 的发生意味着 JVM 停止所有应用线程（STW，Stop-The-World），以回收老年代内存。Full GC 的频率不应过高，如果频繁发生 Full GC，通常是 GC 问题的一个直接表现。
  
#### 2.2 **GC 停顿时间**
- **Minor GC 停顿时间**：Minor GC 发生时，新生代内存被回收，老年代仍然可以正常工作。通常 Minor GC 的停顿时间应该在 **50-200ms** 以内。如果超过这个时间，频繁的 Minor GC 会导致明显的性能问题。
- **Full GC 停顿时间**：Full GC 的停顿时间是系统性能的重要指标。**理想的 Full GC 停顿时间应保持在 1 秒以内**，但这取决于系统的具体要求。如果 Full GC 时间达到 **数秒**甚至 **几十秒**，通常会导致系统不可用，用户体验显著下降。

#### 2.3 **内存回收效率**
- **内存回收率**：每次 GC 后回收的内存量和速度非常重要。你可以在 GC 日志中看到堆内存使用情况，例如：
  ```
  [Full GC (System.gc()) 1024K->256K(8192K), 0.234567 secs]
  ```
  - 上述日志表示 Full GC 发生后，堆内存从 **1024K** 降至 **256K**，耗时 **0.234 秒**。需要评估回收后的堆内存使用量和频率，如果内存没有明显减少，则可能有内存泄漏。

### 3. **使用监控工具检查 GC 的影响**
使用监控工具可以帮助你更加直观地理解 GC 对系统的影响：

#### 3.1 **JVisualVM**
- 使用 **JVisualVM** 连接到正在运行的 JVM，可以查看堆使用情况、GC 的频率和停顿时间。尤其是 **GC 曲线**，你可以观察堆内存的增长和下降趋势。
- **频繁的 GC 曲线波动**：如果频繁看到“齿轮状”的 GC 曲线，则可能意味着频繁的 GC 对系统造成了影响。

#### 3.2 **JConsole**
- **JConsole** 提供了内存池使用和 GC 相关信息，包括 GC 次数和 GC 时间。
- 查看老年代（Old Generation）和新生代（Young Generation）的堆使用情况，判断是否存在内存不断增加、无法被回收的情况。

#### 3.3 **第三方监控工具**
- **Prometheus + Grafana**、**New Relic**、**Dynatrace** 等 APM 工具可以提供更加全面的 JVM 指标，包括内存使用、GC 次数、GC 停顿时间等。
- 这些工具可以设定告警，当 GC 停顿时间超出合理范围时触发告警，方便及时调整。

### 4. **堆内存使用的观察**
通过工具来观察堆内存的使用情况，检查以下内容：
- **新生代频繁满**：如果新生代（Young Generation）频繁满，可能是因为对象创建过于频繁，导致 Minor GC 频率高。
- **老年代不断增大**：老年代（Old Generation）如果不断增大，并且不容易被回收，可能是因为对象过早地进入老年代，这会导致 Full GC 更频繁地发生。
  

可以通过 **`jmap`** 命令生成内存转储（heap dump），然后使用 **Eclipse MAT** 等工具分析，确定是否有内存泄漏或不必要的对象长期驻留。

### 5. **参考的 GC 性能标准**
在不同场景下对 GC 性能的标准判断可能有所不同，但一些通用的参考标准如下：

#### 5.1 **GC 停顿时间标准**
- **Minor GC 停顿**：通常需要保持在 **50-200ms** 以内。如果应用是延迟敏感型的，如实时交易系统，甚至要求低于 **50ms**。
- **Full GC 停顿**：应尽量保持在 **1 秒以内**。如果 Full GC 时间在 **1 秒以上**，可能需要优化 GC 策略或调整堆内存配置。

#### 5.2 **GC 频率**
- **Minor GC**：频率过高（例如每秒多次）通常意味着新生代内存不足。一般情况下，Minor GC 每隔几秒到几十秒发生一次是较为正常的。
- **Full GC**：理想情况下，Full GC 应尽可能少发生，通常建议每小时最多几次。如果 Full GC 频率为每分钟甚至更频繁，则需要进行内存调优。

#### 5.3 **内存回收效率**
- 每次 **Minor GC** 后，**新生代**内存应该大幅减少，说明短生命周期对象被及时清理。
- 每次 **Full GC** 后，**老年代**应该保持在一个稳定的水平。如果每次 Full GC 结束后，老年代的内存使用量仍然较高（接近上限），说明内存回收效率低，可能有内存泄漏或需要增加老年代大小。

### 6. **具体操作和判断过程总结**
以下是具体的步骤来确定 GC 是否引起了性能问题的流程：

1. **收集 GC 日志**：添加 GC 日志参数，运行应用并收集 GC 日志文件。
2. **分析 GC 日志**：查看 GC 日志中的停顿时间、GC 类型（Minor GC 还是 Full GC）、内存回收的情况等。
3. **使用监控工具**：通过 JVisualVM、JConsole 或 APM 工具查看堆内存曲线、GC 次数和停顿时间，判断是否存在过于频繁或过长时间的 GC。
4. **堆内存分析**：使用 `jmap` 获取堆内存转储文件，利用工具（如 Eclipse MAT）分析内存中的对象分布，确定是否有不必要的对象没有被回收。
5. **参考性能标准**：将 GC 停顿时间、GC 频率与参考标准对比。如果发现 GC 频率过高或停顿时间过长，就需要优化 GC 配置。

### 7. **可能的优化措施**
如果确认 GC 是引起性能问题的原因，可以考虑以下优化措施：

- **增大堆内存大小**：增加堆内存的大小可以减少 GC 的频率。例如，`-Xmx` 和 `-Xms` 可以适当调高。
- **调整新生代大小**：增加新生代的大小，减少对象过早进入老年代。
- **选择合适的 GC 策略**：
  - **G1 GC**：适合低停顿时间的需求，使用 `-XX:+UseG1GC`。
  - **ZGC 或 Shenandoah**：对于要求非常低暂停时间的应用，可以考虑使用 ZGC（Java 11 及以上）或 Shenandoah（OpenJDK）。
- **减少对象创建频率**：通过代码优化，减少短生命周期对象的创建数量，使用对象池来复用对象。

### 总结
确定性能问题是否由 GC 引起的主要步骤包括：**收集 GC 日志**、**分析日志中的 GC 停顿时间和频率**、**使用监控工具观察 GC 活动**、**通过堆内存分析判断是否存在内存泄漏**，并且对比相应的 **性能标准**（如 GC 停顿时间和频率）。通过这些手段，你可以系统地判断 GC 是否是造成性能问题的原因，并根据结果采取相应的优化措施。
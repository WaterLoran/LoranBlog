# 如何在设计阶段做代码复杂度分析

在分析与设计阶段进行代码复杂度分析，属于**预测性**的白盒测试手段。它的核心思想是：**不等到代码写完之后才度量复杂度，而是在设计之时，就通过评估设计决策来预测其可能导致的代码复杂度，并提前优化**。

以下是具体的方法、关注点和实例。

---

### 一、核心概念：设计阶段的复杂度分析是什么？

它不是去分析真实的代码，而是：
1.  **评估设计图纸**： 审视架构图、模块划分、类图、序列图、API设计等。
2.  **模拟实现**： 基于设计，预想实现代码的大致结构和关键逻辑。
3.  **预测指标**： 应用复杂度度量模型来预测这个“想象中的代码”的复杂度。
4.  **识别坏味道**： 提前发现那些会导致高复杂度的设计决策。

**目标**： 从源头上避免生成高复杂度的、难以测试和维护的代码。

---

### 二、具体如何做：流程与执行步骤

#### 步骤 1：确定评估对象
选择设计的核心部分进行评估，例如：
*   一个核心业务流程的详细设计
*   一个关键API接口的设计
*   一个核心算法或业务规则的设计
*   一个微服务的模块划分

#### 步骤 2：应用复杂度度量模型进行评估
针对设计，使用以下模型进行预测性分析。

#### 步骤 3：评审与重构设计
根据分析结果，团队讨论设计是否合理。如果预测复杂度太高，则立即**重构设计**，而不是等到编码阶段。

---

### 三、常见的复杂度关注点与设计例子

下面通过具体的设计场景来说明如何预测和分析复杂度。

#### 1. 圈复杂度 (Cyclomatic Complexity) - **预测条件逻辑**

*   **关注点**： 预测一个函数或方法内部**决策路径**的数量。路径越多，越难测试和维护。
*   **设计阶段的分析方法**： 查看序列图或流程图中 `if`、`else`、`switch`、`for`、`while`、`catch` 等决策节点的数量。
*   **计算方式（预测）**： `V(G) = 决策节点数 + 1`

*   **例子：用户订单折扣设计**
    *   **糟糕的设计（高复杂度）**：
        ```java
        // 根据设计描述，我们预见到代码会有很多if-else
        public double calculateDiscount(User user, Order order) {
            if (user.isVIP()) {          // 决策 1
                if (order.getAmount() > 1000) { // 决策 2
                    return 0.2;
                } else if (order.getAmount() > 500) { // 决策 3
                    return 0.1;
                }
            } else {
                if (order.getItems().size() > 5) { // 决策 4
                    return 0.05;
                }
            }
            if (isHolidaySeason()) {     // 决策 5
                return 0.03;
            }
            return 0;
        }
        ```
        *   **预测圈复杂度**： 我们数一下设计中的条件判断：`user.isVIP()`, `order.getAmount() > 1000`, `order.getAmount() > 500`, `order.getItems().size() > 5`, `isHolidaySeason()`。共 **5** 个决策节点。`V(G) = 5 + 1 = 6`。
        *   **问题**： 这意味着至少需要 **6** 个测试用例才能覆盖所有分支。规则耦合在一起，难以理解和修改。

    *   **优化后的设计（低复杂度）**：
        *   **重构策略**： **策略模式 (Strategy Pattern)** + **规则链**。
        *   **设计描述**：
            1.  定义折扣规则接口 `DiscountRule`： `boolean appliesTo(User user, Order order); double getDiscount();`
            2.  创建多个独立规则类： `VIPLargeOrderRule`, `VIPMediumOrderRule`, `LargeQuantityRule`, `HolidaySeasonRule`, `NoDiscountRule`。
            3.  创建一个规则引擎，按优先级遍历这些规则，找到第一个适用的并返回折扣。
        *   **预测复杂度**： 每个规则类的 `appliesTo` 方法只有 **1-2** 个简单判断，复杂度极低。引擎的 `calculate` 方法只是一个循环，复杂度也很低。
        *   **优势**： 每个规则可独立测试、复用和修改，符合单一职责原则。

#### 2. 认知复杂度 (Cognitive Complexity) - **预测可读性**

*   **关注点**： 预测一段代码**被人类理解的难易程度**。它更关心嵌套、连续的逻辑操作符等。
*   **设计阶段的分析方法**： 审视设计是否存在**深度嵌套**（`if` 中的 `if`）、复杂的布尔表达式、大量的流程跳转。

*   **例子：数据校验设计**
    *   **糟糕的设计（高认知复杂度）**：
        ```java
        // 设计描述：需要满足所有条件才能提交
        if (user != null) { // 嵌套层 1
            if (user.isActive()) { // 嵌套层 2
                if (order != null && order.isValid()) { // 嵌套层 3 + 布尔组合
                    if (!order.isSubmitted()) { // 嵌套层 4
                        // 提交订单
                    } else {
                        throw new AlreadySubmittedException();
                    }
                } else {
                    throw new InvalidOrderException();
                }
            } else {
                throw new InactiveUserException();
            }
        } else {
            throw new UserNotFoundException();
        }
        ```
        *   **问题**： **“箭头型代码”**，深度嵌套，需要在大脑中层层推理，非常难理解。

    *   **优化后的设计（低认知复杂度）**：
        *   **重构策略**： **卫语句 (Guard Clause)** —— 先检查失败条件，提前返回。
        *   **设计描述**：
            ```java
            // 提前返回所有错误情况
            if (user == null) {
                throw new UserNotFoundException();
            }
            if (!user.isActive()) {
                throw new InactiveUserException();
            }
            if (order == null || !order.isValid()) { // 逻辑不变，但放在同一层
                throw new InvalidOrderException();
            }
            if (order.isSubmitted()) {
                throw new AlreadySubmittedException();
            }
            // 主逻辑：所有校验通过，提交订单
            ```
        *   **优势**： 扁平化结构，清晰地将异常路径与主成功路径分离，极易阅读和理解。

#### 3. 耦合度 (Coupling) & 内聚度 (Cohesion)

*   **关注点**：
    *   **耦合度**： 预测模块/类之间的**依赖程度**。高耦合意味着修改一个模块会严重影响其他模块。
    *   **内聚度**： 预测一个模块/类内部职责的**单一程度**。高内聚意味着一个模块只做好一件事。
*   **设计阶段的分析方法**： 审视**架构图**和**类图**。

*   **例子：模块设计**
    *   **糟糕的设计（高耦合，低内聚）**：
        *   **设计描述**： 有一个 `OrderService`，它直接调用了 `EmailService` 发送邮件、调用 `SmsService` 发短信、调用 `InventoryService` 扣库存、调用 `PaymentService` 处理支付，还包含了生成PDF报表的逻辑。
        *   **问题**：
            *   **低内聚**： `OrderService` 职责过多，不仅是订单核心逻辑，还包含了通知、报表等无关职责。
            *   **高耦合**： `OrderService` 直接依赖了太多具体的下游服务，任何一个服务接口变动都会导致它要修改。

    *   **优化后的设计（低耦合，高内聚）**：
        *   **重构策略**： **依赖倒置原则 (DIP)** + **领域事件 (Domain Events)**。
        *   **设计描述**：
            1.  **提炼核心职责**： `OrderService` 只负责订单的核心生命周期（创建、支付、取消）。
            2.  **事件驱动**： 当订单状态发生变化时（如`OrderPaidEvent`），`OrderService` 只是发布一个事件，不关心谁来处理。
            3.  **解耦处理**： 独立的 `EmailEventHandler`、`SmsEventHandler`、`ReportGeneratorEventHandler` 来监听和处理这些事件。
        *   **优势**：
            *   **高内聚**： 每个服务职责单一。
            *   **低耦合**： `OrderService` 不再直接依赖任何通知或报表服务，只依赖一个抽象的 `EventPublisher`。新增一个处理逻辑（如发微信）完全不需要修改 `OrderService`。

#### 4. 扇入/扇出 (Fan-in / Fan-out)

*   **关注点**：
    *   **扇出**： 预测一个类直接依赖的其他类的数量。**扇出过高**意味着该类可能过于复杂，协调太多事情。
    *   **扇入**： 预测有多少个类依赖当前类。**扇入过高**意味着该类是核心通用类，修改需要格外小心。
*   **设计阶段的分析方法**： 数一数类图上的依赖关系箭头。

---

### 四、可执行的技术方案

1.  **建立设计评审清单**： 将上述关注点转化为团队的设计评审检查项。
2.  **可视化设计**： **强制要求**在评审前提供关键流程的流程图或序列图。图形化能极大地帮助发现复杂度问题。
3.  **设定质量门禁**： 在设计文档中定义复杂度目标。
    *   “本服务模块的设计，应确保核心函数的预测圈复杂度不超过 **10**。”
    *   “模块间的耦合度应遵循依赖倒置原则，不允许高层模块直接依赖低层模块的实现。”
4.  **使用工具辅助（伪代码分析）**： 虽然无法直接分析设计图，但可以将关键算法用伪代码或简单代码写出来，然后用 **SonarQube**、**Checkstyle** 等工具对这段示例代码进行扫描，作为复杂度预测的参考。

### 总结

在设计阶段进行复杂度分析，是一种**防患于未然**的高级工程实践。它要求架构师和开发人员具备以下能力：

*   **预见性**： 能够从设计图预见代码的实现结构。
*   **度量能力**： 掌握圈复杂度、耦合度等量化模型。
*   **重构意识**： 一旦预测到高复杂度，能立即运用设计模式（策略、工厂、观察者/事件）和设计原则（SOLID）来重构设计。

最终目标不是消除复杂度（业务复杂度是固有的），而是**避免不必要的、由糟糕设计带来的偶然复杂度**，从而在项目伊始就打造出高可维护、高可测试的代码基底。
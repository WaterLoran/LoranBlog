Allure Report 本身**不存储历史数据**，其历史趋势图和多版本比较功能主要依赖以下技术原理实现：

## 核心原理：报告生成与数据聚合

1.  **历史趋势图：**
    *   **数据来源：** 每次生成 Allure Report 时，Allure 会创建一个包含本次测试执行关键统计信息的 JSON 文件（通常是 `history.json` 或 `history-trend.json`，位于报告的 `history` 目录下）。这个文件包含的信息通常有：
        *   测试总数
        *   通过数
        *   失败数
        *   跳过数
        *   阻塞数
        *   未知/中断数
        *   执行持续时间
        *   **构建标识符：** 通常是构建号（如 Jenkins `BUILD_NUMBER`）或时间戳，用于区分不同次执行。
        *   **报告目录名：** 包含本次报告数据的目录名（通常是构建号或时间戳）。
    *   **聚合过程：**
        *   在生成**新的** Allure Report 时，Allure 会**查找并读取**一个特定的目录（通常由 `--history-dir` 参数指定，或默认在报告输出目录下的 `history` 目录）。
        *   它会尝试加载该目录下**所有**之前生成的 `history.json` 文件。
        *   这些加载的历史数据会被**解析、排序**（通常按构建号或时间戳）。
        *   Allure 将**当前**执行的统计信息与加载的**历史**统计信息**合并**在一起。
        *   **可视化：** 合并后的数据集（包含当前和多个历史构建的数据点）被用来渲染报告首页的**历史趋势图**。X 轴通常是构建号/时间，Y 轴是数量（总测试数、失败数等）或通过率。
    *   **依赖：** 这个功能**完全依赖**于之前生成的报告数据（特别是 `history.json` 文件）是否被正确保存并放置在 `--history-dir` 指向的目录中。如果该目录被清空或配置错误，历史趋势图将无法显示或只显示当前构建。

2.  **多版本比较：**
    *   **本质：** Allure **原生不直接提供**一个在单一报告内可视化比较两个任意历史版本所有差异的功能。它主要提供的是**单个报告内的历史趋势图**（如上所述）和**单个报告内不同测试用例的历史状态**（通过用例详情页的 History 小部件查看该用例在最近几次构建中的状态变化）。
    *   **实现方式：**
        *   **独立报告：** “多版本比较”通常意味着你有多个独立的 Allure Report 目录，每个目录对应一个软件版本（或一个 Git 提交、一次构建）。你需要分别打开这些报告，并在浏览器标签页之间手动切换、观察差异。
        *   **报告聚合工具：** 社区或第三方开发了一些工具来解决更强大的多版本比较需求：
            *   **Allure Report Aggregator:** 这类工具（例如 `allure-combine` 或定制的脚本）可以读取多个独立的 Allure 报告目录（每个代表一个版本/构建），将它们的数据**合并**成一个**新的、单一的** Allure Report。在这个合并后的报告中：
                *   历史趋势图会包含所有被合并构建的数据点。
                *   测试用例详情页的 History 小部件会显示该用例在**所有被合并构建**中的执行状态。
                *   这实质上实现了在**一个报告内**查看**多个特定版本**的历史执行情况，便于比较。
            *   **CI/CD 集成与标签：** 在 CI/CD 流程中：
                *   为每次构建/部署生成的 Allure Report 打上明确的**标签**（如 `version=1.2.3`, `commit=abc123`, `env=staging`）。
                *   将报告存档并发布到一个集中的存储（如对象存储 S3/MinIO、静态文件服务器、Artifactory/Nexus、或 CI 系统的归档功能）。
                *   开发一个简单的**仪表板或索引页面**，列出所有存档的报告及其标签（版本、环境、时间等）。用户通过这个入口选择两个或多个报告进行查看比较（仍然需要打开多个标签页）。
            *   **商业/高级解决方案：** 一些商业的测试管理平台或高级报告系统可能内建了更强大的 Allure 报告存储、索引和可视化比较功能，能够直接在 UI 上并排显示不同版本的报告差异（如失败用例对比、新出现的失败等）。

## 关键技术与依赖

1.  **文件系统：** 核心依赖文件系统来存储历史报告目录和其中的 `history.json` 文件。
2.  **CI/CD 流水线：** 实现自动化的历史报告保存和传递至关重要：
    *   每次构建后，生成的 Allure Report 必须被**存档**（复制到特定位置，如 `history_dir` 目录或一个中央存储）。
    *   在生成新报告时，CI 脚本需要将**之前存档的报告数据复制到新报告的 `history` 目录下**（或配置 `--history-dir` 指向存档位置）。
    *   对于多版本比较（聚合方式），CI 流水线需要在需要时触发报告聚合任务。
3.  **构建标识符：** 清晰、唯一、递增的构建号或时间戳是区分不同执行和排序历史数据的关键。
4.  **版本标签：** 为了进行有意义的版本比较，需要在生成报告时或归档时打上准确的软件版本号或 Git 提交哈希等标签。

## 总结

*   **历史趋势图：** 基于**聚合**当前构建 + 之前构建保存的 `history.json` 文件数据生成。依赖 CI 正确保存和传递历史报告数据。
*   **原生多版本比较：** 主要指查看**单个报告内**的趋势图或**单个用例的历史状态变化**。跨独立报告的比较需要手动切换或借助索引。
*   **增强版多版本比较：** 通过**报告聚合工具**将多个独立报告的数据合并成一个新报告，实现单报告内多版本历史查看；或通过 **CI/CD 标签 + 报告存档 + 索引页面** 来管理多个报告便于手动比较。

简而言之，Allure 提供了生成历史数据文件和在单个报告中聚合展现这些数据的能力，但**历史数据的持久化存储、管理和跨版本的深度比较功能则需要依赖外部系统（主要是 CI/CD 流程和可能的附加工具）来实现**。
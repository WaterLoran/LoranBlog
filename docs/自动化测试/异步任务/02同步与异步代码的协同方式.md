# 02同步与异步代码的协同方式

在Python中混合使用同步和异步代码时，需要注意它们的协同方式。以下是详细的分析和示例：

## 1. **基本原则**

### 同步代码中调用异步代码
```python
import asyncio

# 异步函数
async def async_task():
    await asyncio.sleep(1)
    return "异步任务完成"

# 同步代码调用异步函数的方法：

# 方法1: asyncio.run() - 最常用的方式
def sync_caller_1():
    result = asyncio.run(async_task())
    print(f"同步函数调用结果: {result}")

# 方法2: 在已有的事件循环中
def sync_caller_2():
    loop = asyncio.new_event_loop()
    try:
        result = loop.run_until_complete(async_task())
        print(f"结果: {result}")
    finally:
        loop.close()
```

### 异步代码中调用同步代码
```python
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor

# 同步阻塞函数
def sync_blocking_task(seconds):
    time.sleep(seconds)  # 同步阻塞
    return f"同步任务完成，耗时{seconds}秒"

# 异步函数调用同步代码的几种方式：

async def async_caller():
    # 方法1: 直接调用（会阻塞事件循环，不推荐）
    # result = sync_blocking_task(2)  # 不推荐！
    
    # 方法2: 使用run_in_executor（推荐）
    loop = asyncio.get_running_loop()
    
    # 在线程池中执行同步函数
    result = await loop.run_in_executor(
        None,  # 使用默认的ThreadPoolExecutor
        sync_blocking_task, 2
    )
    print(f"异步调用同步函数结果: {result}")
    
    # 方法3: 使用自定义线程池
    with ThreadPoolExecutor(max_workers=3) as pool:
        result = await loop.run_in_executor(
            pool, 
            sync_blocking_task, 3
        )
        print(f"使用自定义线程池结果: {result}")
```

## 2. **完整实战示例**

```python
import asyncio
import time
import requests
from concurrent.futures import ThreadPoolExecutor

# ========== 同步部分 ==========
class DatabaseManager:
    """同步数据库操作类"""
    def __init__(self):
        self.data = {}
    
    def sync_query(self, key):
        """模拟同步数据库查询"""
        time.sleep(0.5)  # 模拟IO阻塞
        return self.data.get(key, f"{key}: 未找到")
    
    def sync_save(self, key, value):
        """模拟同步数据库保存"""
        time.sleep(0.3)
        self.data[key] = value
        return f"已保存: {key}={value}"

# ========== 异步部分 ==========
class AsyncAPIClient:
    """异步HTTP客户端"""
    
    async def async_fetch_data(self, url):
        """异步获取数据"""
        await asyncio.sleep(1)  # 模拟网络请求
        
        # 这里演示一个真实场景：在异步函数中调用同步的requests
        # 需要使用run_in_executor来避免阻塞事件循环
        loop = asyncio.get_running_loop()
        response = await loop.run_in_executor(
            None,
            requests.get, url  # requests是同步库
        )
        return {
            "url": url,
            "status": response.status_code,
            "data": response.text[:100] if response.text else ""
        }
    
    async def async_process_data(self, data):
        """异步处理数据"""
        await asyncio.sleep(0.5)
        return {"processed": True, "data": data}

# ========== 混合调度器 ==========
class HybridScheduler:
    def __init__(self):
        self.db = DatabaseManager()
        self.api_client = AsyncAPIClient()
        self.executor = ThreadPoolExecutor(max_workers=5)
    
    async def mixed_workflow(self, user_id):
        """混合工作流：同时使用同步和异步代码"""
        
        # 1. 异步获取外部数据
        api_task = asyncio.create_task(
            self.api_client.async_fetch_data("https://httpbin.org/get")
        )
        
        # 2. 并行执行同步数据库查询（不阻塞事件循环）
        loop = asyncio.get_running_loop()
        db_query_task = loop.run_in_executor(
            self.executor,
            self.db.sync_query, user_id
        )
        
        # 3. 等待两个任务完成
        api_result, db_result = await asyncio.gather(api_task, db_query_task)
        
        # 4. 异步处理数据
        processed = await self.api_client.async_process_data(api_result)
        
        # 5. 同步保存结果到数据库
        save_result = await loop.run_in_executor(
            self.executor,
            self.db.sync_save, 
            f"user_{user_id}",
            str(processed)
        )
        
        return {
            "api_data": api_result,
            "db_query": db_result,
            "processed": processed,
            "save_result": save_result
        }
    
    def sync_entry_point(self, user_ids):
        """同步入口点：从同步代码启动异步工作流"""
        results = []
        
        for user_id in user_ids:
            # 每次调用asyncio.run()都会创建新的事件循环
            result = asyncio.run(self.mixed_workflow(user_id))
            results.append(result)
            
        return results

# ========== 高级模式：单事件循环处理多个同步调用 ==========
async def batch_sync_operations():
    """批量处理同步操作"""
    loop = asyncio.get_running_loop()
    
    # 同时运行多个同步操作
    tasks = []
    for i in range(5):
        task = loop.run_in_executor(
            None,
            lambda x: (time.sleep(0.5), f"任务{x}完成")[1],
            i
        )
        tasks.append(task)
    
    results = await asyncio.gather(*tasks)
    return results

# ========== 使用示例 ==========
async def main_async():
    """异步主函数"""
    scheduler = HybridScheduler()
    
    # 运行混合工作流
    result = await scheduler.mixed_workflow("user123")
    print("混合工作流结果:", result)
    
    # 批量处理同步操作
    batch_results = await batch_sync_operations()
    print("批量结果:", batch_results)

def main_sync():
    """同步主函数"""
    scheduler = HybridScheduler()
    
    # 同步代码中调用异步逻辑
    results = scheduler.sync_entry_point(["user1", "user2", "user3"])
    print("批量用户处理结果:", results)

if __name__ == "__main__":
    print("=== 异步入口 ===")
    asyncio.run(main_async())
    
    print("\n=== 同步入口 ===")
    main_sync()
```

## 3. **关键模式和最佳实践**

### 模式1：包装器模式
```python
def sync_wrapper(async_func):
    """将异步函数包装为同步函数"""
    def wrapper(*args, **kwargs):
        return asyncio.run(async_func(*args, **kwargs))
    return wrapper

# 使用
@sync_wrapper
async def download_url(url):
    # 异步下载逻辑
    await asyncio.sleep(1)
    return f"下载完成: {url}"

# 现在可以在同步代码中直接调用
result = download_url("https://example.com")
```

### 模式2：异步适配器
```python
import functools

async def async_adapter(sync_func, *args, **kwargs):
    """将同步函数适配为异步调用"""
    loop = asyncio.get_running_loop()
    
    # 使用partial绑定参数
    func = functools.partial(sync_func, *args, **kwargs)
    
    # 在后台线程执行
    return await loop.run_in_executor(None, func)
```

### 模式3：混合类设计
```python
class HybridService:
    def __init__(self):
        self._loop = None
        
    async def __aenter__(self):
        self._loop = asyncio.get_running_loop()
        return self
    
    def sync_method(self):
        """同步方法"""
        return "同步结果"
    
    async def async_method(self):
        """异步方法"""
        # 在异步方法中调用同步方法
        result = await self._loop.run_in_executor(
            None, self.sync_method
        )
        
        # 继续异步处理
        await asyncio.sleep(0.1)
        return f"处理后的: {result}"
    
    async def __aexit__(self, *args):
        pass
```

## 4. **注意事项和常见陷阱**

1. **不要混用asyncio.run()**
   ```python
   # 错误：嵌套使用asyncio.run()
   def wrong():
       result = asyncio.run(some_async_func())  # 创建新事件循环
       # 在另一个asyncio.run()中又调用async函数 ❌
   
   # 正确：使用一个asyncio.run()包装所有异步操作
   async def all_async_ops():
       a = await some_async_func()
       b = await another_async_func()
       return a, b
   
   def correct():
       results = asyncio.run(all_async_ops())
   ```

2. **性能考虑**
   - 使用 `run_in_executor` 会有线程切换开销
   - 对于CPU密集型任务，使用 `ProcessPoolExecutor` 而不是 `ThreadPoolExecutor`
   - 避免在热路径上频繁切换同步/异步上下文

3. **异常处理差异**
   ```python
   try:
       # 同步异常
       sync_func()
   except SomeError:
       pass
   
   try:
       # 异步异常
       await async_func()
   except SomeError:
       pass
   ```

## 5. **架构建议**

1. **明确边界**：在架构设计时明确哪些模块是同步的，哪些是异步的
2. **适配层**：在同步和异步边界处创建适配层
3. **依赖注入**：根据上下文注入不同的实现（同步/异步）
4. **文档说明**：清晰标注函数的同步/异步性质

这种混合模式在实际项目中非常常见，特别是：
- 逐步迁移：将同步项目逐步迁移到异步
- 依赖限制：某些依赖库只提供同步API
- 性能优化：在异步框架中执行同步CPU密集型任务
(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{552:function(t,s,r){"use strict";r.r(s);var a=r(2),n=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"登陆显示无相关权限问题定位"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#登陆显示无相关权限问题定位"}},[t._v("#")]),t._v(" 登陆显示无相关权限问题定位")]),t._v(" "),s("h2",{attrs:{id:"背景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),s("p",[t._v("某离岸团队负责人终于找到了我, 说是环境登陆上去, 没有权限了, 让我帮忙解决一下.")]),t._v(" "),s("h2",{attrs:{id:"我定位的过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#我定位的过程"}},[t._v("#")]),t._v(" 我定位的过程")]),t._v(" "),s("ol",[s("li",[t._v("先看看镜像\n因为出问题时间 是昨天下午4点, 所以, 看看有无服务的镜像是在昨天下午4点左右部署上去的, 这里尝试回退了几个服务的版本不能找到问题. (现在分析, 发现只要镜像部署上去了, 升级脚本就会修改了相关数据库的数据了, 就算回退镜像也没有什么用了)")]),t._v(" "),s("li",[t._v("看看接口的差异\n和运维看了下接口的差异, 有个接口旧版本是true, 新版本是false, 但是问了前端, 他说这个就是某个小的业务的权限.")]),t._v(" "),s("li",[t._v("问问熟悉的前端相关的接口\n于是跟前端, 反复确认, 各种追问, 最有可能出现问题的接口是哪个, 这个前端的权限的相关逻辑是什么样子的.")]),t._v(" "),s("li",[t._v("对比一下目标接口和老接口的响应数据\n确定最大相关的接口就是, XX_permission, 于是, 我就把他的响应拿出来, 和旧版本的相同接口的数据比较. 用ultraCompare 来比较, 发现, 还是有很多内容不一样的, 虽然那个ID一样, 但是部分信息的sortid 不一样啊.")]),t._v(" "),s("li",[t._v("了解一下权限的前后台原理\n大概我就猜测, 前端请求回来这个权限数据, 还是要去二次处理的")]),t._v(" "),s("li",[t._v("了解一下最近开发的需求\n回忆了一下, 确实有个需求, 更改了权限的相关逻辑, 所以嘛, 确实也是会有可能更改了目标接口的响应内容的, 我就比较有信心, 大概是这个接口的改动引入的, 然后就推测大概是没有和前端共同协商处理该接口的数据, 仅仅是后端单方面修改而引入的.")]),t._v(" "),s("li",[t._v("用burpsuit篡改改接口数据来精确定位接口问题\n为了验证, 是要前后端配合的, (我怀疑就只改后端, 前端没有对应修改). 所以, 我用就有问题版本的目标接口的响应数据, 用burpsuit 窜改成了 旧版本的响应数据, 然后发现是能够获得权限并使用的.\n所以, 到这里就已经能够确认是这个接口的数据除了问题.")])])])}),[],!1,null,null,null);s.default=n.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{599:function(s,a,t){"use strict";t.r(a);var _=t(2),r=Object(_.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("在 MySQL 8 中，锁争用（lock contention）是导致查询性能下降、系统吞吐量减低的常见原因。锁争用问题通常会导致查询等待时间增加，甚至发生死锁。排查锁争用可以帮助优化数据库的并发性能。下面是排查 MySQL 8 中锁争用的常用方法和步骤。")]),s._v(" "),a("h3",{attrs:{id:"_1-查看当前的锁等待"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-查看当前的锁等待"}},[s._v("#")]),s._v(" 1. "),a("strong",[s._v("查看当前的锁等待")])]),s._v(" "),a("p",[s._v("MySQL 8 提供了多种方式来检查当前是否有锁争用，包括 "),a("code",[s._v("performance_schema")]),s._v(" 表和 "),a("code",[s._v("SHOW ENGINE INNODB STATUS")]),s._v(" 命令。")]),s._v(" "),a("h4",{attrs:{id:"_1-1-使用-performance-schema-data-locks-和-data-lock-waits"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-使用-performance-schema-data-locks-和-data-lock-waits"}},[s._v("#")]),s._v(" 1.1 "),a("strong",[s._v("使用 "),a("code",[s._v("performance_schema.data_locks")]),s._v(" 和 "),a("code",[s._v("data_lock_waits")])])]),s._v(" "),a("p",[s._v("MySQL 8 的 "),a("code",[s._v("performance_schema")]),s._v(" 模块包含 "),a("code",[s._v("data_locks")]),s._v(" 和 "),a("code",[s._v("data_lock_waits")]),s._v(" 表，它们可以用来查看当前系统中的锁和锁等待情况。")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 查看当前的锁")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" performance_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("data_locks"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 查看当前的锁等待情况")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" performance_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("data_lock_waits"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("ul",[a("li",[a("strong",[a("code",[s._v("performance_schema.data_locks")])]),s._v("：显示系统中所有持有的锁。")]),s._v(" "),a("li",[a("strong",[a("code",[s._v("performance_schema.data_lock_waits")])]),s._v("：显示当前所有锁等待的详细信息，包括持有锁的事务和正在等待该锁的事务。")])]),s._v(" "),a("h4",{attrs:{id:"_1-2-使用-show-engine-innodb-status"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-使用-show-engine-innodb-status"}},[s._v("#")]),s._v(" 1.2 "),a("strong",[s._v("使用 "),a("code",[s._v("SHOW ENGINE INNODB STATUS")])])]),s._v(" "),a("p",[a("code",[s._v("SHOW ENGINE INNODB STATUS")]),s._v(" 是另一种用来排查锁争用的常用命令，它显示了当前 InnoDB 存储引擎的详细运行状态，包括事务信息、锁等待、死锁等。")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHOW")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ENGINE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("INNODB")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("STATUS")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("在输出的 "),a("strong",[s._v("TRANSACTIONS")]),s._v(" 部分，你可以看到当前正在等待的锁情况。如果存在锁等待或锁超时，会在输出中清晰显示哪些事务正在等待以及等待的时间。")]),s._v(" "),a("h4",{attrs:{id:"关键信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关键信息"}},[s._v("#")]),s._v(" 关键信息：")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("TRANSACTIONS")]),s._v("：展示了当前正在进行的事务，哪些事务在等待锁。")]),s._v(" "),a("li",[a("strong",[s._v("WAITING FOR THIS LOCK TO BE GRANTED")]),s._v("：表示事务正在等待一个锁的释放。")]),s._v(" "),a("li",[a("strong",[s._v("LATEST DETECTED DEADLOCK")]),s._v("：如果有死锁发生，会在这里显示最近的死锁信息。")])]),s._v(" "),a("h3",{attrs:{id:"_2-使用-show-processlist-检查锁等待"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用-show-processlist-检查锁等待"}},[s._v("#")]),s._v(" 2. "),a("strong",[s._v("使用 "),a("code",[s._v("SHOW PROCESSLIST")]),s._v(" 检查锁等待")])]),s._v(" "),a("p",[a("code",[s._v("SHOW PROCESSLIST")]),s._v(" 可以帮助你查看当前所有连接的状态，尤其是哪些查询正在等待锁。")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHOW")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FULL")]),s._v(" PROCESSLIST"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("ul",[a("li",[a("strong",[s._v("Command")]),s._v(" 列：如果显示 "),a("code",[s._v("Locked")]),s._v("，说明该查询正在等待获取锁。")]),s._v(" "),a("li",[a("strong",[s._v("Time")]),s._v(" 列：显示查询已经等待了多长时间。")]),s._v(" "),a("li",[a("strong",[s._v("Info")]),s._v(" 列：显示正在执行的 SQL 语句。")])]),s._v(" "),a("p",[s._v("你可以通过 "),a("code",[s._v("SHOW FULL PROCESSLIST")]),s._v(" 来定位那些长时间处于 "),a("code",[s._v("Locked")]),s._v(" 状态的查询，并结合事务或锁信息进一步分析。")]),s._v(" "),a("h3",{attrs:{id:"_3-死锁检测与分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-死锁检测与分析"}},[s._v("#")]),s._v(" 3. "),a("strong",[s._v("死锁检测与分析")])]),s._v(" "),a("p",[s._v("MySQL 8 自动检测死锁，并会记录最近一次死锁的详细信息。可以通过 "),a("code",[s._v("SHOW ENGINE INNODB STATUS")]),s._v(" 查看最新的死锁报告。")]),s._v(" "),a("h4",{attrs:{id:"_3-1-查看最近的死锁信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-查看最近的死锁信息"}},[s._v("#")]),s._v(" 3.1 "),a("strong",[s._v("查看最近的死锁信息")])]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHOW")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ENGINE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("INNODB")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("STATUS")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("在 "),a("strong",[s._v("LATEST DETECTED DEADLOCK")]),s._v(" 部分，你可以看到死锁的详细信息，包括哪个事务被 MySQL 选择回滚、哪些锁导致了死锁、以及参与死锁的 SQL 语句。")]),s._v(" "),a("h4",{attrs:{id:"_3-2-启用-innodb-print-all-deadlocks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-启用-innodb-print-all-deadlocks"}},[s._v("#")]),s._v(" 3.2 "),a("strong",[s._v("启用 "),a("code",[s._v("innodb_print_all_deadlocks")])])]),s._v(" "),a("p",[s._v("如果你想让所有死锁都记录到错误日志中，而不仅仅是最近一次死锁，你可以启用 "),a("code",[s._v("innodb_print_all_deadlocks")]),s._v(" 选项：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SET")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("GLOBAL")]),s._v(" innodb_print_all_deadlocks "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'ON'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("这会让 MySQL 将所有的死锁记录到错误日志文件中，你可以定期查看日志文件了解死锁情况。")]),s._v(" "),a("h3",{attrs:{id:"_4-事务隔离级别和锁等待"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-事务隔离级别和锁等待"}},[s._v("#")]),s._v(" 4. "),a("strong",[s._v("事务隔离级别和锁等待")])]),s._v(" "),a("p",[s._v("MySQL 支持不同的事务隔离级别，不同的隔离级别对锁的处理有所不同。你可以通过调整事务的隔离级别来减少锁争用。")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("READ UNCOMMITTED")]),s._v("：事务可以读取未提交的数据，几乎不会引发锁争用，但可能导致“脏读”问题。")]),s._v(" "),a("li",[a("strong",[s._v("READ COMMITTED")]),s._v("：只能读取已提交的数据，锁冲突较少，是常用的隔离级别之一。")]),s._v(" "),a("li",[a("strong",[s._v("REPEATABLE READ")]),s._v("（默认级别）：避免“幻读”和“不可重复读”，但可能增加锁争用。")]),s._v(" "),a("li",[a("strong",[s._v("SERIALIZABLE")]),s._v("：最严格的隔离级别，可能导致最多的锁争用。")])]),s._v(" "),a("h4",{attrs:{id:"_4-1-查看当前隔离级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-查看当前隔离级别"}},[s._v("#")]),s._v(" 4.1 "),a("strong",[s._v("查看当前隔离级别")])]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHOW")]),s._v(" VARIABLES "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("LIKE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'transaction_isolation'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("h4",{attrs:{id:"_4-2-调整隔离级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-调整隔离级别"}},[s._v("#")]),s._v(" 4.2 "),a("strong",[s._v("调整隔离级别")])]),s._v(" "),a("p",[s._v("你可以通过降低隔离级别（如从 "),a("code",[s._v("SERIALIZABLE")]),s._v(" 降为 "),a("code",[s._v("READ COMMITTED")]),s._v("）来减少锁争用：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SET")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("GLOBAL")]),s._v(" transaction_isolation "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'READ COMMITTED'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("也可以在事务内部指定隔离级别，以便局部控制：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SET")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TRANSACTION")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ISOLATION")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LEVEL")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("READ")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COMMITTED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("h3",{attrs:{id:"_5-锁等待超时设置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-锁等待超时设置"}},[s._v("#")]),s._v(" 5. "),a("strong",[s._v("锁等待超时设置")])]),s._v(" "),a("p",[s._v("MySQL 提供了锁等待超时设置，防止长时间的锁等待影响系统性能。")]),s._v(" "),a("h4",{attrs:{id:"_5-1-查看锁等待超时设置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-查看锁等待超时设置"}},[s._v("#")]),s._v(" 5.1 "),a("strong",[s._v("查看锁等待超时设置")])]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHOW")]),s._v(" VARIABLES "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("LIKE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'innodb_lock_wait_timeout'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("ul",[a("li",[a("strong",[s._v("innodb_lock_wait_timeout")]),s._v("：控制事务等待锁的最大时间（单位为秒）。如果锁等待时间超过该值，MySQL 会返回错误并回滚事务。")])]),s._v(" "),a("h4",{attrs:{id:"_5-2-调整锁等待超时"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-调整锁等待超时"}},[s._v("#")]),s._v(" 5.2 "),a("strong",[s._v("调整锁等待超时")])]),s._v(" "),a("p",[s._v("你可以通过调整该参数来控制锁等待的最大时间，避免锁等待时间过长：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SET")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("GLOBAL")]),s._v(" innodb_lock_wait_timeout "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("30")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 设置为30秒")]),s._v("\n")])])]),a("p",[s._v("合理设置超时时间可以有效防止长时间的锁争用。")]),s._v(" "),a("h3",{attrs:{id:"_6-锁争用的解决与优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-锁争用的解决与优化"}},[s._v("#")]),s._v(" 6. "),a("strong",[s._v("锁争用的解决与优化")])]),s._v(" "),a("h4",{attrs:{id:"_6-1-缩短事务的执行时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-缩短事务的执行时间"}},[s._v("#")]),s._v(" 6.1 "),a("strong",[s._v("缩短事务的执行时间")])]),s._v(" "),a("ul",[a("li",[s._v("确保事务尽量简短，避免长时间持有锁。可以将大型事务拆分为多个小事务，减少锁的持有时间。")]),s._v(" "),a("li",[s._v("将较复杂的查询放在事务之外，尽量减少在事务中执行复杂的查询操作。")])]),s._v(" "),a("h4",{attrs:{id:"_6-2-使用合适的索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-使用合适的索引"}},[s._v("#")]),s._v(" 6.2 "),a("strong",[s._v("使用合适的索引")])]),s._v(" "),a("ul",[a("li",[s._v("确保查询中的 "),a("code",[s._v("WHERE")]),s._v(" 子句和 "),a("code",[s._v("JOIN")]),s._v(" 操作使用了适当的索引，减少扫描的行数，从而减少锁的范围和锁争用。")]),s._v(" "),a("li",[s._v("避免在事务中使用 "),a("code",[s._v("SELECT *")]),s._v("，只查询必要的列，以减少锁的行数和大小。")])]),s._v(" "),a("h4",{attrs:{id:"_6-3-表分区与分表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-表分区与分表"}},[s._v("#")]),s._v(" 6.3 "),a("strong",[s._v("表分区与分表")])]),s._v(" "),a("ul",[a("li",[s._v("如果某张表非常大，可以考虑使用 "),a("strong",[s._v("分区表")]),s._v(" 或 "),a("strong",[s._v("分表")]),s._v(" 来减少单个表的锁范围。")]),s._v(" "),a("li",[s._v("表分区有助于减少锁定的范围和影响，特别是在高并发写入的场景中。")])]),s._v(" "),a("h4",{attrs:{id:"_6-4-适当使用乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-适当使用乐观锁"}},[s._v("#")]),s._v(" 6.4 "),a("strong",[s._v("适当使用乐观锁")])]),s._v(" "),a("ul",[a("li",[s._v("对于不频繁发生冲突的场景，可以考虑使用乐观锁（如通过版本号控制并发更新），从而避免传统悲观锁带来的性能问题。")])]),s._v(" "),a("h4",{attrs:{id:"_6-5-避免长时间持有锁的读写操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-避免长时间持有锁的读写操作"}},[s._v("#")]),s._v(" 6.5 "),a("strong",[s._v("避免长时间持有锁的读写操作")])]),s._v(" "),a("ul",[a("li",[s._v("长时间的读写操作（如批量更新、复杂查询）可能会长时间占用锁资源，建议这些操作在业务低峰期执行，或者分批处理，以减少对锁的争用。")])]),s._v(" "),a("h3",{attrs:{id:"_7-实时监控与报警"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-实时监控与报警"}},[s._v("#")]),s._v(" 7. "),a("strong",[s._v("实时监控与报警")])]),s._v(" "),a("p",[s._v("为了及时发现锁争用问题，你可以使用监控工具（如 Prometheus + Grafana）来实时监控 MySQL 的锁等待、锁争用情况。你可以通过监控以下指标来识别潜在的问题：")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("锁等待时间")]),s._v("：通过 "),a("code",[s._v("performance_schema")]),s._v(" 表获取锁等待时间。")]),s._v(" "),a("li",[a("strong",[s._v("事务执行时间")]),s._v("：监控长时间运行的事务，识别可能存在锁争用的事务。")]),s._v(" "),a("li",[a("strong",[s._v("死锁检测")]),s._v("：及时发现并报警。")])]),s._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("排查 MySQL 8 中的锁争用可以通过以下几步进行：")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("使用 "),a("code",[s._v("performance_schema.data_locks")]),s._v(" 和 "),a("code",[s._v("data_lock_waits")]),s._v(" 查看当前的锁和锁等待情况")]),s._v("。")]),s._v(" "),a("li",[a("strong",[s._v("使用 "),a("code",[s._v("SHOW ENGINE INNODB STATUS")]),s._v(" 分析锁等待和死锁信息")]),s._v("。")]),s._v(" "),a("li",[a("strong",[s._v("使用 "),a("code",[s._v("SHOW PROCESSLIST")]),s._v(" 检查长时间等待的查询")]),s._v("。")]),s._v(" "),a("li",[a("strong",[s._v("分析事务隔离级别")]),s._v("，并通过调整隔离级别减少锁争用。")]),s._v(" "),a("li",[a("strong",[s._v("调整锁等待超时设置")]),s._v("，防止长时间锁等待影响系统性能。")]),s._v(" "),a("li",[a("strong",[s._v("缩短事务执行时间、增加索引、优化查询结构")]),s._v("，减少锁争用。")]),s._v(" "),a("li",[a("strong",[s._v("通过监控工具")]),s._v(" 实时监控锁争用情况并进行报警。")])]),s._v(" "),a("p",[s._v("通过以上步骤，你可以识别并解决 MySQL 8 中的锁争用问题，从而提升数据库的并发性能和响应速度。")])])}),[],!1,null,null,null);a.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[213],{639:function(v,_,s){"use strict";s.r(_);var t=s(2),e=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("在一次典型的"),_("strong",[v._v("写入和读取Redis中的数据")]),v._v("过程中，涉及多个步骤，从客户端请求发起到数据存储在内存中再到结果返回。以下是具体的过程描述，包括底层的处理机制：")]),v._v(" "),_("h3",{attrs:{id:"一、写入数据的过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、写入数据的过程"}},[v._v("#")]),v._v(" 一、写入数据的过程")]),v._v(" "),_("h4",{attrs:{id:"_1-客户端发起请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-客户端发起请求"}},[v._v("#")]),v._v(" 1. "),_("strong",[v._v("客户端发起请求")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("请求启动")]),v._v(" "),_("p",[v._v("：客户端通过与Redis服务器建立的TCP连接向Redis发送")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("SET\n")])])]),_("p",[v._v("命令。这个命令的格式通常为：")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("vbnet复制代码SET key value\n")])])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("请求端口")]),v._v("：Redis默认监听的端口是"),_("strong",[v._v("6379")]),v._v("，客户端会通过该端口将请求发送到Redis服务器。客户端与服务器之间使用的协议是"),_("strong",[v._v("RESP（REdis Serialization Protocol）")]),v._v("，该协议非常高效且轻量。")])])]),v._v(" "),_("h4",{attrs:{id:"_2-redis接收请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis接收请求"}},[v._v("#")]),v._v(" 2. "),_("strong",[v._v("Redis接收请求")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("网络层接收")]),v._v("：Redis通过事件驱动模型（基于"),_("strong",[v._v("epoll")]),v._v("或"),_("strong",[v._v("select")]),v._v("等I/O多路复用技术）监听端口。当请求到达时，Redis服务器的"),_("strong",[v._v("主线程")]),v._v("从TCP连接中读取客户端请求数据包。")]),v._v(" "),_("li",[_("strong",[v._v("请求解析")]),v._v("：Redis通过RESP协议对客户端发送的数据进行解析。解析过程中，Redis会将"),_("code",[v._v("SET")]),v._v("命令、"),_("code",[v._v("key")]),v._v("和"),_("code",[v._v("value")]),v._v("分离出来并传递给处理逻辑。")])]),v._v(" "),_("h4",{attrs:{id:"_3-处理写入命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-处理写入命令"}},[v._v("#")]),v._v(" 3. "),_("strong",[v._v("处理写入命令")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("查找键空间")]),v._v(" "),_("p",[v._v("：Redis会将解析后的")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("key\n")])])]),_("p",[v._v("传递给内部的")]),v._v(" "),_("p",[v._v("键空间（Keyspace）")]),v._v(" "),_("p",[v._v("。键空间是一个")]),v._v(" "),_("p",[v._v("字典（哈希表）")]),v._v(" "),_("p",[v._v("，Redis通过哈希算法查找是否存在这个")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("key\n")])])]),_("p",[v._v("。")]),v._v(" "),_("ul",[_("li",[v._v("如果键不存在，Redis会直接创建新的"),_("code",[v._v("key")]),v._v("并为其分配内存空间。")]),v._v(" "),_("li",[v._v("如果键已经存在，Redis将更新这个键的值。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("写入数据")]),v._v("：Redis通过将解析出来的"),_("code",[v._v("value")]),v._v("存储在内存中。Redis中的数据结构已经优化，字符串（String）、哈希（Hash）、列表（List）、集合（Set）等数据类型都能在内存中快速存储。")])])]),v._v(" "),_("h4",{attrs:{id:"_4-内存管理与分配"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-内存管理与分配"}},[v._v("#")]),v._v(" 4. "),_("strong",[v._v("内存管理与分配")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("内存分配")]),v._v("：Redis依赖操作系统进行内存管理，但Redis使用了一些内存优化机制，例如"),_("strong",[v._v("jemalloc")]),v._v("分配器来高效管理和分配内存。"),_("code",[v._v("key-value")]),v._v("对存储在内存中对应的数据结构中，内存分配器负责为每个新数据分配内存空间。")]),v._v(" "),_("li",[_("strong",[v._v("数据写入完成")]),v._v("：完成内存分配后，Redis将"),_("code",[v._v("value")]),v._v("存储到哈希表的指定位置，并将相关元数据（如过期时间、数据类型）一并存储。")])]),v._v(" "),_("h4",{attrs:{id:"_5-持久化-可选"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-持久化-可选"}},[v._v("#")]),v._v(" 5. "),_("strong",[v._v("持久化（可选）")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("AOF日志记录")]),v._v("：如果Redis配置了**AOF（Append-Only File）**持久化方式，Redis会在处理完写操作后，将该操作（如"),_("code",[v._v("SET key value")]),v._v("）以追加的方式写入AOF日志。AOF可以通过不同的策略（如"),_("code",[v._v("everysec")]),v._v("）来同步到磁盘。")]),v._v(" "),_("li",[_("strong",[v._v("RDB快照")]),v._v("：如果Redis使用了"),_("strong",[v._v("RDB持久化")]),v._v("，写入操作不会立即被记录，但当Redis触发RDB快照时，会将内存中的所有数据序列化并写入磁盘。")])]),v._v(" "),_("h4",{attrs:{id:"_6-返回结果"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-返回结果"}},[v._v("#")]),v._v(" 6. "),_("strong",[v._v("返回结果")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("执行完成")]),v._v('：当Redis完成数据写入操作后，主线程会将响应消息（例如"OK"）通过同一条TCP连接返回给客户端，表明写操作成功。')]),v._v(" "),_("li",[_("strong",[v._v("网络发送响应")]),v._v("：响应结果通过TCP协议返回到客户端，客户端收到响应后可以确认数据已经写入成功。")])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"二、读取数据的过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、读取数据的过程"}},[v._v("#")]),v._v(" 二、读取数据的过程")]),v._v(" "),_("h4",{attrs:{id:"_1-客户端发起请求-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-客户端发起请求-2"}},[v._v("#")]),v._v(" 1. "),_("strong",[v._v("客户端发起请求")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("读取请求启动")]),v._v(" "),_("p",[v._v("：客户端向Redis发送")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("GET\n")])])]),_("p",[v._v("命令，请求获取某个")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("key\n")])])]),_("p",[v._v("对应的值。请求的命令格式通常为：")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("vbnet复制代码GET key\n")])])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("连接端口")]),v._v("：同样，客户端通过TCP连接与Redis服务器进行通信，请求通过"),_("strong",[v._v("6379端口")]),v._v("发送。")])])]),v._v(" "),_("h4",{attrs:{id:"_2-redis接收读取请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis接收读取请求"}},[v._v("#")]),v._v(" 2. "),_("strong",[v._v("Redis接收读取请求")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("监听端口并接收请求")]),v._v("：Redis的主线程监听请求，当检测到客户端的"),_("code",[v._v("GET")]),v._v("请求时，Redis通过TCP连接读取请求数据包。")]),v._v(" "),_("li",[_("strong",[v._v("请求解析")]),v._v("：Redis使用RESP协议解析请求，提取出"),_("code",[v._v("GET")]),v._v("命令和对应的"),_("code",[v._v("key")]),v._v("。")])]),v._v(" "),_("h4",{attrs:{id:"_3-查找键空间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-查找键空间"}},[v._v("#")]),v._v(" 3. "),_("strong",[v._v("查找键空间")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("键空间查找")]),v._v(" "),_("p",[v._v("：Redis通过哈希算法快速查找")]),v._v(" "),_("p",[v._v("键空间")]),v._v(" "),_("p",[v._v("中的")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("key\n")])])]),_("p",[v._v("。由于Redis的键空间是基于")]),v._v(" "),_("p",[v._v("哈希表（Hash Table）"),_("strong",[v._v("实现的，查找的时间复杂度为")]),v._v("O(1)")]),v._v(" "),_("p",[v._v("。")]),v._v(" "),_("ul",[_("li",[v._v("如果"),_("code",[v._v("key")]),v._v("存在，Redis会获取该"),_("code",[v._v("key")]),v._v("对应的值。")]),v._v(" "),_("li",[v._v("如果"),_("code",[v._v("key")]),v._v("不存在，Redis会返回空值（"),_("code",[v._v("nil")]),v._v("）给客户端。")])])])]),v._v(" "),_("h4",{attrs:{id:"_4-读取数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-读取数据"}},[v._v("#")]),v._v(" 4. "),_("strong",[v._v("读取数据")])]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("直接从内存中读取数据")]),v._v("：由于Redis的数据全部存储在内存中，读取数据的速度非常快。Redis通过哈希表中的指针直接访问存储在内存中的"),_("code",[v._v("value")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("数据类型处理")]),v._v(" "),_("p",[v._v("：根据键空间中的数据类型，Redis可以处理多种数据类型的读取操作：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("字符串（String）")]),v._v("：直接返回字符串值。")]),v._v(" "),_("li",[_("strong",[v._v("哈希（Hash）")]),v._v("：返回哈希中的指定字段。")]),v._v(" "),_("li",[_("strong",[v._v("列表（List）")]),v._v("：返回列表中的指定元素或子列表。")]),v._v(" "),_("li",[_("strong",[v._v("集合（Set）")]),v._v("：返回集合中的成员。")]),v._v(" "),_("li",[_("strong",[v._v("有序集合（Sorted Set）")]),v._v("：返回指定分数区间内的成员。")])])])]),v._v(" "),_("h4",{attrs:{id:"_5-返回结果"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-返回结果"}},[v._v("#")]),v._v(" 5. "),_("strong",[v._v("返回结果")])]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("发送数据到客户端")]),v._v("：一旦Redis成功找到"),_("code",[v._v("key")]),v._v("并从内存中读取到"),_("code",[v._v("value")]),v._v("，它会将"),_("code",[v._v("value")]),v._v("通过TCP连接发送给客户端。")])]),v._v(" "),_("li",[_("p",[v._v("响应格式")]),v._v(" "),_("p",[v._v("：结果以RESP协议格式返回，通常以")]),v._v(" "),_("p",[v._v("字符串形式")]),v._v(" "),_("p",[v._v("返回值（或")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("nil\n")])])]),_("p",[v._v("表示键不存在）。")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v('swift复制代码"$5\\r\\nvalue\\r\\n"\n')])])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("客户端接收结果")]),v._v("：客户端通过TCP连接读取响应数据，并提取出结果值。此时，读取操作完成。")])])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"三、总结与关键点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、总结与关键点"}},[v._v("#")]),v._v(" 三、总结与关键点")]),v._v(" "),_("h4",{attrs:{id:"写入流程关键点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#写入流程关键点"}},[v._v("#")]),v._v(" 写入流程关键点：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("TCP连接与RESP协议")]),v._v("：Redis使用RESP协议在客户端和服务器之间进行通信，通过"),_("strong",[v._v("6379端口")]),v._v("监听和接收请求。")]),v._v(" "),_("li",[_("strong",[v._v("单线程处理")]),v._v("：Redis是"),_("strong",[v._v("单线程")]),v._v("模型，无需担心多线程的锁竞争问题，因此处理请求非常快速。")]),v._v(" "),_("li",[_("strong",[v._v("内存存储")]),v._v("：Redis的核心是将数据存储在内存中，写入操作不涉及磁盘，因此速度极快。")]),v._v(" "),_("li",[_("strong",[v._v("持久化（可选）")]),v._v("：Redis可以选择将写操作持久化到磁盘，具体方式取决于AOF或RDB的配置。")])]),v._v(" "),_("h4",{attrs:{id:"读取流程关键点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#读取流程关键点"}},[v._v("#")]),v._v(" 读取流程关键点：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("快速键查找")]),v._v("：Redis的"),_("strong",[v._v("键空间")]),v._v("基于哈希表，查找"),_("code",[v._v("key")]),v._v("的速度是"),_("strong",[v._v("O(1)")]),v._v("，因此可以非常快地找到所需的数据。")]),v._v(" "),_("li",[_("strong",[v._v("内存读取")]),v._v("：所有数据都存储在内存中，读取时直接从内存中获取，避免了磁盘IO，读取速度极快。")]),v._v(" "),_("li",[_("strong",[v._v("多种数据结构")]),v._v("：Redis支持多种数据结构，每种数据结构的读取都被高度优化，确保在内存中高效处理。")])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"四、redis性能优化的技术亮点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、redis性能优化的技术亮点"}},[v._v("#")]),v._v(" 四、Redis性能优化的技术亮点")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("单线程模型")]),v._v("：Redis采用单线程事件驱动模型，避免了多线程中上下文切换和锁争用问题，极大提升了请求处理速度。")]),v._v(" "),_("li",[_("strong",[v._v("I/O多路复用")]),v._v("：Redis利用I/O多路复用机制（如"),_("code",[v._v("epoll")]),v._v("），可以高效地处理大量并发请求。")]),v._v(" "),_("li",[_("strong",[v._v("内存数据结构优化")]),v._v("：Redis通过针对不同应用场景的数据结构（如String、List、Set、Hash等）进行优化，确保在内存中处理数据的速度极快。")]),v._v(" "),_("li",[_("strong",[v._v("持久化可配置")]),v._v("：Redis的AOF和RDB持久化机制可以根据需求灵活配置，既可以保证数据的持久化，也可以在需要时关闭持久化，完全依赖内存以获取最高性能。")])]),v._v(" "),_("p",[v._v("Redis的高效性能归功于其内存数据存储模型、轻量级的命令操作、以及单线程处理机制。这些特性使得Redis在处理高并发、低延迟场景时表现极为出色。")])])}),[],!1,null,null,null);_.default=e.exports}}]);
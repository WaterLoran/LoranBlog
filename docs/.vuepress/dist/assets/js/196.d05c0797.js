(window.webpackJsonp=window.webpackJsonp||[]).push([[196],{631:function(v,t,_){"use strict";_.r(t);var a=_(2),s=Object(a.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[t("code",[v._v("jstat")]),v._v(" 是 Java 提供的用于监控 JVM 性能和垃圾回收的命令行工具，它可以帮助你实时查看 JVM 内存使用情况和 GC 活动。以下是关于 "),t("code",[v._v("jstat")]),v._v(" 命令的用法以及各个指标的详细解读：")]),v._v(" "),t("h3",{attrs:{id:"_1-jstat-命令的基本使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-jstat-命令的基本使用"}},[v._v("#")]),v._v(" 1. "),t("code",[v._v("jstat")]),v._v(" 命令的基本使用")]),v._v(" "),t("p",[t("code",[v._v("jstat")]),v._v(" 命令允许你查看运行中的 Java 虚拟机（JVM）的各种统计信息，尤其是在垃圾回收和内存管理方面的统计。")]),v._v(" "),t("p",[v._v("基本语法：")]),v._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[v._v("jstat "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[v._v("-gc")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("pid"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("interval"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("count"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v("\n")])])]),t("ul",[t("li",[t("strong",[v._v("-gc")]),v._v("：指定要查看的统计信息类型，这里 "),t("code",[v._v("-gc")]),v._v(" 表示查看 GC 和内存相关的信息。")]),v._v(" "),t("li",[t("strong",[v._v("pid")]),v._v("：目标 Java 应用的进程 ID。")]),v._v(" "),t("li",[t("strong",[v._v("interval")]),v._v("：刷新间隔（毫秒），在此示例中为 "),t("code",[v._v("1000")]),v._v("，即每 1 秒钟刷新一次。")]),v._v(" "),t("li",[t("strong",[v._v("count")]),v._v("：数据输出的次数，省略时将会持续输出，直到手动停止（如使用 "),t("code",[v._v("Ctrl+C")]),v._v("）。")])]),v._v(" "),t("p",[v._v("在你的示例中：")]),v._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[v._v("./jstat "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[v._v("-gc")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("8")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("1000")]),v._v("\n")])])]),t("p",[v._v("这表示每隔 1 秒钟查看 PID 为 "),t("code",[v._v("8")]),v._v(" 的 Java 进程的 GC 和内存状态。")]),v._v(" "),t("h3",{attrs:{id:"_2-jstat-gc-输出指标解读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-jstat-gc-输出指标解读"}},[v._v("#")]),v._v(" 2. "),t("code",[v._v("jstat -gc")]),v._v(" 输出指标解读")]),v._v(" "),t("p",[v._v("下面对 "),t("code",[v._v("jstat -gc")]),v._v(" 输出中的各个列指标进行详细说明：")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v(" S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   \n26176.0 26176.0 4750.6  0.0   209792.0 77728.5   786432.0   117260.4  124348.0 118318.9 14528.0 13419.1    152    2.692   6      0.178    2.870\n")])])]),t("p",[v._v("各个指标的解释如下：")]),v._v(" "),t("h4",{attrs:{id:"新生代-young-generation-相关指标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生代-young-generation-相关指标"}},[v._v("#")]),v._v(" "),t("strong",[v._v("新生代（Young Generation）相关指标")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("S0C（Survivor 0 Capacity）")]),v._v("：第一个 Survivor 区的容量（KB）。表示 S0 区的大小。")]),v._v(" "),t("li",[t("strong",[v._v("S1C（Survivor 1 Capacity）")]),v._v("：第二个 Survivor 区的容量（KB）。表示 S1 区的大小。")]),v._v(" "),t("li",[t("strong",[v._v("S0U（Survivor 0 Utilization）")]),v._v("：第一个 Survivor 区的已用空间（KB）。表示当前 S0 区中已经使用的内存。")]),v._v(" "),t("li",[t("strong",[v._v("S1U（Survivor 1 Utilization）")]),v._v("：第二个 Survivor 区的已用空间（KB）。表示当前 S1 区中已经使用的内存。")]),v._v(" "),t("li",[t("strong",[v._v("EC（Eden Capacity）")]),v._v("：Eden 区的容量（KB）。Eden 是新生代中最先分配对象的区域。")]),v._v(" "),t("li",[t("strong",[v._v("EU（Eden Utilization）")]),v._v("：Eden 区的已用空间（KB）。表示当前 Eden 区中已经使用的内存。")])]),v._v(" "),t("p",[v._v("这些指标反映了新生代各个区域的内存分配和利用情况。新生代用于存储新创建的对象，GC 主要发生在 Eden 区，当 Eden 满时，会触发 Minor GC，将存活的对象移至 Survivor 区。")]),v._v(" "),t("h4",{attrs:{id:"老年代-old-generation-相关指标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#老年代-old-generation-相关指标"}},[v._v("#")]),v._v(" "),t("strong",[v._v("老年代（Old Generation）相关指标")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("OC（Old Capacity）")]),v._v("：老年代的容量（KB）。用于存放经过多次 Minor GC 后仍然存活的对象。")]),v._v(" "),t("li",[t("strong",[v._v("OU（Old Utilization）")]),v._v("：老年代的已用空间（KB）。表示当前老年代中已经使用的内存。")])]),v._v(" "),t("p",[v._v("老年代主要存放生命周期较长的对象，如果老年代的使用率接近容量上限，可能会引发 Full GC，这是一种较为耗时的 GC 类型。")]),v._v(" "),t("h4",{attrs:{id:"元空间-metaspace-相关指标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元空间-metaspace-相关指标"}},[v._v("#")]),v._v(" "),t("strong",[v._v("元空间（Metaspace）相关指标")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("MC（Metaspace Capacity）")]),v._v("：元空间（Metaspace）的容量（KB）。在 Java 8 及更高版本中，元空间取代了之前的永久代（PermGen），用于存放类的元数据。")]),v._v(" "),t("li",[t("strong",[v._v("MU（Metaspace Utilization）")]),v._v("：元空间已用空间（KB）。表示当前元空间中已经使用的内存。")])]),v._v(" "),t("p",[v._v("元空间用于存储类的元数据，例如类定义、方法信息等。如果元空间不足，可能会引起类加载异常或性能问题。")]),v._v(" "),t("h4",{attrs:{id:"压缩类空间-compressed-class-space-相关指标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#压缩类空间-compressed-class-space-相关指标"}},[v._v("#")]),v._v(" "),t("strong",[v._v("压缩类空间（Compressed Class Space）相关指标")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("CCSC（Compressed Class Space Capacity）")]),v._v("：压缩类空间的容量（KB）。专门用于存储类的元数据信息。")]),v._v(" "),t("li",[t("strong",[v._v("CCSU（Compressed Class Space Utilization）")]),v._v("：压缩类空间的已用空间（KB）。表示当前压缩类空间中已经使用的内存。")])]),v._v(" "),t("h4",{attrs:{id:"gc-统计相关指标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc-统计相关指标"}},[v._v("#")]),v._v(" "),t("strong",[v._v("GC 统计相关指标")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("YGC（Young GC Count）")]),v._v("：从 JVM 启动以来发生的 Minor GC（新生代 GC）次数。")]),v._v(" "),t("li",[t("strong",[v._v("YGCT（Young GC Time）")]),v._v("：从 JVM 启动以来在 Minor GC 上花费的总时间（秒）。")])]),v._v(" "),t("p",[v._v("这些指标可以用来分析 Minor GC 是否频繁，是否对性能有较大影响。理想情况下，Minor GC 频率应该保持在合理范围内，时间应该尽可能短。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("FGC（Full GC Count）")]),v._v("：从 JVM 启动以来发生的 Full GC（老年代 GC）次数。")]),v._v(" "),t("li",[t("strong",[v._v("FGCT（Full GC Time）")]),v._v("：从 JVM 启动以来在 Full GC 上花费的总时间（秒）。")])]),v._v(" "),t("p",[v._v("Full GC 是非常耗时的操作，Full GC 次数过多通常意味着老年代内存被频繁填满，可能会导致应用停顿（Stop-The-World）。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("GCT（Total GC Time）")]),v._v("：从 JVM 启动以来 GC（包括 Minor 和 Full GC）花费的总时间（秒）。")])]),v._v(" "),t("p",[t("code",[v._v("GCT")]),v._v(" 表示应用因 GC 而暂停的时间。通过它可以判断 JVM 在垃圾回收上消耗的资源情况。")]),v._v(" "),t("h3",{attrs:{id:"_3-如何解读这些指标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何解读这些指标"}},[v._v("#")]),v._v(" 3. "),t("strong",[v._v("如何解读这些指标")])]),v._v(" "),t("p",[v._v("根据你给出的数据：")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("26176.0 26176.0 4750.6  0.0   209792.0 77728.5   786432.0   117260.4  124348.0 118318.9 14528.0 13419.1    152    2.692   6      0.178    2.870\n26176.0 26176.0  0.0   6582.2 209792.0   0.0     786432.0   117410.7  124348.0 118318.9 14528.0 13419.1    153    2.706   6      0.178    2.884\n")])])]),t("p",[v._v("从这些数据中可以得到以下结论：")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("新生代内存利用情况")]),v._v("：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Eden 区（EU）")]),v._v(" 使用率（如 77728.5）表明 Eden 区目前正在被活跃使用，这也是正常的内存分配区域。")]),v._v(" "),t("li",[t("strong",[v._v("Survivor 区（S0U/S1U）")]),v._v(" 数据显示存活的对象逐渐被移到 Survivor 区（0.0 或较低的数字表明部分对象被回收）。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("老年代（OC 和 OU）")]),v._v("：")]),v._v(" "),t("ul",[t("li",[v._v("老年代容量为 "),t("strong",[v._v("786432.0 KB")]),v._v("，使用了 "),t("strong",[v._v("117260.4 KB")]),v._v(" 和 "),t("strong",[v._v("117410.7 KB")]),v._v("，说明目前的内存压力并不大。注意老年代容量如果接近上限，就会触发 Full GC，这可能导致性能问题。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("GC 频率和时间")]),v._v("：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("YGC = 152 和 153")]),v._v("，表明已经发生了 153 次 Minor GC，总时间为 "),t("strong",[v._v("2.706 秒")]),v._v("。每次 Minor GC 的时间非常短（大约 0.017 秒），说明目前 Minor GC 对应用的影响不大。")]),v._v(" "),t("li",[t("strong",[v._v("FGC = 6")]),v._v("，表明发生了 6 次 Full GC，总时间为 "),t("strong",[v._v("0.178 秒")]),v._v("，说明 Full GC 还不是特别频繁。")])])])]),v._v(" "),t("h3",{attrs:{id:"_4-判断-gc-是否引发了性能问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-判断-gc-是否引发了性能问题"}},[v._v("#")]),v._v(" 4. "),t("strong",[v._v("判断 GC 是否引发了性能问题")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Minor GC（YGC 和 YGCT）")]),v._v("：如果 Minor GC 次数非常频繁，比如每秒多次，可能导致响应时间增加。在你的数据中，152 次 Minor GC 总共花费约 2.7 秒，平均每次 Minor GC 的时间较短，这一般不会严重影响性能。")]),v._v(" "),t("li",[t("strong",[v._v("Full GC（FGC 和 FGCT）")]),v._v("：Full GC 是代价最高的回收类型。如果 Full GC 的次数非常多，或者每次 Full GC 花费时间较长（大于 1 秒），则可能引起严重的性能问题。在你的数据中，6 次 Full GC 总共花费了 0.178 秒，平均每次 Full GC 的时间较短，说明目前 GC 并未导致性能瓶颈。")])]),v._v(" "),t("h3",{attrs:{id:"_5-如何优化-gc-相关配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-如何优化-gc-相关配置"}},[v._v("#")]),v._v(" 5. "),t("strong",[v._v("如何优化 GC 相关配置")])]),v._v(" "),t("p",[v._v("如果发现 GC 引起了性能问题，可以考虑以下优化措施：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("增大堆内存大小")]),v._v("：增加堆内存的大小，可以减少 GC 的频率。可以通过设置 JVM 参数 "),t("code",[v._v("-Xmx")]),v._v(" 和 "),t("code",[v._v("-Xms")]),v._v(" 来增加最大和最小堆内存。")]),v._v(" "),t("li",[t("strong",[v._v("调整新生代和老年代的比例")]),v._v("：通过 "),t("code",[v._v("-XX:NewRatio")]),v._v(" 和 "),t("code",[v._v("-XX:SurvivorRatio")]),v._v(" 来调整新生代、老年代和 Survivor 区的比例，确保新生代能够更好地回收短生命周期对象。")]),v._v(" "),t("li",[t("strong",[v._v("选择合适的 GC 策略")]),v._v("：\n"),t("ul",[t("li",[t("strong",[v._v("G1 GC")]),v._v("：对于延迟敏感的应用，推荐使用 G1 GC（"),t("code",[v._v("-XX:+UseG1GC")]),v._v("），它可以减少 Stop-The-World 的时间。")]),v._v(" "),t("li",[t("strong",[v._v("ZGC 或 Shenandoah GC")]),v._v("：对于极低延迟需求的应用，可以考虑使用 ZGC（Java 11 及以上）或 Shenandoah（OpenJDK 支持），这些 GC 都是低延迟的垃圾回收器。")])])])]),v._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("p",[t("code",[v._v("jstat")]),v._v(" 工具可以实时查看 JVM 的垃圾回收和内存使用情况，帮助你了解 Java 应用在运行过程中内存分配是否合理。通过 "),t("code",[v._v("jstat -gc")]),v._v(" 命令输出的指标（如新生代使用、老年代使用、GC 次数和时间等），可以判断 JVM 是否存在 GC 引起的性能问题，并采取适当的措施来优化系统性能。")])])}),[],!1,null,null,null);t.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{571:function(_,v,t){"use strict";t.r(v);var r=t(2),e=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("线程池配置是影响系统并发处理能力和性能的一个关键因素。配置不当可能导致线程资源耗尽，系统响应时间增加，或者线程数量过多导致上下文切换的开销过大。以下是关于如何配置线程池的一些建议，包括一些具体的参数配置和适用场景的分析：")]),_._v(" "),v("h3",{attrs:{id:"_1-核心概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-核心概念"}},[_._v("#")]),_._v(" 1. "),v("strong",[_._v("核心概念")])]),_._v(" "),v("p",[_._v("在配置线程池之前，首先理解线程池的几个核心参数：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("核心线程数（corePoolSize）")]),_._v("：线程池维护的最小线程数，即使这些线程空闲，也不会被回收。")]),_._v(" "),v("li",[v("strong",[_._v("最大线程数（maximumPoolSize）")]),_._v("：线程池能够创建的最大线程数，当任务量大于核心线程数时，会创建新线程，直到达到最大线程数。")]),_._v(" "),v("li",[v("strong",[_._v("队列容量（workQueue）")]),_._v("：任务队列的大小，超过核心线程数的任务会先进入队列排队。")]),_._v(" "),v("li",[v("strong",[_._v("线程存活时间（keepAliveTime）")]),_._v("：空闲线程在销毁前的存活时间，仅对超过核心线程数的线程有效。")]),_._v(" "),v("li",[v("strong",[_._v("拒绝策略（RejectedExecutionHandler）")]),_._v("：当线程数达到最大限制且队列已满时如何处理新任务，有四种策略：抛出异常、直接丢弃、丢弃最旧任务、或者由调用者自己处理。")])]),_._v(" "),v("h3",{attrs:{id:"_2-线程池配置要点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-线程池配置要点"}},[_._v("#")]),_._v(" 2. "),v("strong",[_._v("线程池配置要点")])]),_._v(" "),v("p",[_._v("配置线程池时，需要结合业务场景的特点和资源情况，以避免资源过度消耗或者系统性能下降。")]),_._v(" "),v("h4",{attrs:{id:"_2-1-核心线程数-corepoolsize-配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-核心线程数-corepoolsize-配置"}},[_._v("#")]),_._v(" 2.1 "),v("strong",[_._v("核心线程数 (corePoolSize) 配置")])]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("CPU 密集型任务")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("核心线程数 = CPU 核心数 + 1")])]),_._v(" "),v("li",[_._v("CPU 密集型任务是指那些主要消耗 CPU 资源的任务，线程数配置略大于 CPU 核心数可以有效地利用 CPU 资源。"),v("code",[_._v("+1")]),_._v(" 是为了应对一些 I/O 操作或者其他非 CPU 密集的情况，使 CPU 资源更充分利用。")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("I/O 密集型任务")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("核心线程数 = 2 * CPU 核心数")])]),_._v(" "),v("li",[_._v("I/O 密集型任务在运行时会有很多等待 I/O 操作的时间，比如读写文件、访问数据库等。此时可以配置更多的线程来掩盖 I/O 等待的时间，以便其他线程可以在 I/O 等待期间继续工作。")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("混合任务")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("对于既有 CPU 密集型操作也有 I/O 密集型操作的混合任务，需要通过实际测试找到合适的核心线程数。一般建议从略高于 CPU 核心数的值开始进行性能测试，并逐步调整以找出合适的配置。")])])])]),_._v(" "),v("h4",{attrs:{id:"_2-2-最大线程数-maximumpoolsize-配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-最大线程数-maximumpoolsize-配置"}},[_._v("#")]),_._v(" 2.2 "),v("strong",[_._v("最大线程数 (maximumPoolSize) 配置")])]),_._v(" "),v("ul",[v("li",[_._v("最大线程数的配置需要考虑系统硬件资源（尤其是 CPU、内存）的能力，以及应用的负载情况：\n"),v("ul",[v("li",[_._v("如果最大线程数设置得过大，系统将面临大量的线程上下文切换开销，反而导致整体性能降低。")]),_._v(" "),v("li",[_._v("在设置最大线程数时，通常根据业务需求来确定。对于 I/O 密集型任务，可以设置为核心线程数的 2 到 3 倍，但具体需要通过负载测试来确认系统的瓶颈和资源消耗。")])])])]),_._v(" "),v("h4",{attrs:{id:"_2-3-队列容量-workqueue-配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-队列容量-workqueue-配置"}},[_._v("#")]),_._v(" 2.3 "),v("strong",[_._v("队列容量 (workQueue) 配置")])]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("有界队列")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("使用有限大小的队列")]),_._v("，比如 "),v("code",[_._v("LinkedBlockingQueue")]),_._v("，适合对请求数有一定控制的场景。队列满时不会无限增加任务，防止内存溢出。")]),_._v(" "),v("li",[_._v("队列大小需要根据系统的内存资源和吞吐量来合理设定，过大可能会占用大量内存，过小可能无法满足高峰期的请求。")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("无界队列")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("使用 "),v("strong",[_._v("无界队列")]),_._v("，如 "),v("code",[_._v("SynchronousQueue")]),_._v("，适合负载较小但对响应时间有较高要求的场景。在使用无界队列时，注意如果请求量增加得很快而线程创建速度跟不上，就会导致内存占用增加，甚至导致系统崩溃。")])])])]),_._v(" "),v("h4",{attrs:{id:"_2-4-线程存活时间-keepalivetime-配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-线程存活时间-keepalivetime-配置"}},[_._v("#")]),_._v(" 2.4 "),v("strong",[_._v("线程存活时间 (keepAliveTime) 配置")])]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("短时高并发任务")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("如果线程池在高并发请求结束后要迅速释放线程，以便节约系统资源，可以设置较短的存活时间，如 30 秒。")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("长时间需要保持线程数稳定")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("对于需要长时间保持较高处理能力的应用，可以设置较长的存活时间，以避免频繁地创建和销毁线程带来的开销。")])])])]),_._v(" "),v("h4",{attrs:{id:"_2-5-拒绝策略-rejectedexecutionhandler-配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-拒绝策略-rejectedexecutionhandler-配置"}},[_._v("#")]),_._v(" 2.5 "),v("strong",[_._v("拒绝策略 (RejectedExecutionHandler) 配置")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("AbortPolicy")]),_._v("（默认策略）：当任务队列已满且线程数达到最大时，抛出 "),v("code",[_._v("RejectedExecutionException")]),_._v("，适合必须立即知道任务被拒绝的场景。")]),_._v(" "),v("li",[v("strong",[_._v("DiscardPolicy")]),_._v("：直接丢弃新任务，不抛异常，适合对丢弃某些任务有容忍度的场景。")]),_._v(" "),v("li",[v("strong",[_._v("DiscardOldestPolicy")]),_._v("：丢弃最早的任务，尝试重新执行新任务，适合必须保证最新任务执行的场景。")]),_._v(" "),v("li",[v("strong",[_._v("CallerRunsPolicy")]),_._v("：由调用线程处理该任务，适合任务不多，但重要性较高的场景，确保不会直接丢弃任务，但有可能会导致调用方阻塞。")])]),_._v(" "),v("h3",{attrs:{id:"_3-不同场景的线程池配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-不同场景的线程池配置"}},[_._v("#")]),_._v(" 3. "),v("strong",[_._v("不同场景的线程池配置")])]),_._v(" "),v("p",[_._v("以下是针对不同应用场景的一些线程池配置建议：")]),_._v(" "),v("h4",{attrs:{id:"_3-1-web-服务器或应用服务器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-web-服务器或应用服务器"}},[_._v("#")]),_._v(" 3.1 "),v("strong",[_._v("Web 服务器或应用服务器")])]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("任务特性")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("大量并发请求，短时间内可能有大量请求涌入。")]),_._v(" "),v("li",[_._v("请求的处理通常包括 I/O 操作（如数据库访问、文件读写）。")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("配置建议")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("核心线程数")]),_._v("可以设置为 "),v("code",[_._v("CPU 核心数")]),_._v("到 "),v("code",[_._v("2 * CPU 核心数")]),_._v("之间。")]),_._v(" "),v("li",[v("strong",[_._v("最大线程数")]),_._v("可以设置为核心线程数的 "),v("code",[_._v("2~3 倍")]),_._v("。")]),_._v(" "),v("li",[v("strong",[_._v("队列容量")]),_._v("根据平均请求量和系统内存资源来确定，比如 500 或 1000。")]),_._v(" "),v("li",[v("strong",[_._v("拒绝策略")]),_._v("建议使用 "),v("code",[_._v("CallerRunsPolicy")]),_._v("，这样在高峰期调用方可以自己处理任务，从而避免系统资源进一步恶化。")])])])]),_._v(" "),v("h4",{attrs:{id:"_3-2-批处理任务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-批处理任务"}},[_._v("#")]),_._v(" 3.2 "),v("strong",[_._v("批处理任务")])]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("任务特性")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("批处理任务通常对时间的要求不那么敏感，注重任务的执行完毕。")]),_._v(" "),v("li",[_._v("任务之间通常没有依赖性，可以并行处理。")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("配置建议")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("核心线程数")]),_._v("可以设置为 "),v("code",[_._v("CPU 核心数")]),_._v("。")]),_._v(" "),v("li",[v("strong",[_._v("最大线程数")]),_._v("设置为 "),v("code",[_._v("CPU 核心数 + 1")]),_._v("，确保尽可能利用多核优势。")]),_._v(" "),v("li",[v("strong",[_._v("队列容量")]),_._v("可以较大，例如 "),v("code",[_._v("1000")]),_._v("，因为批处理任务可以在队列中等待执行。")]),_._v(" "),v("li",[v("strong",[_._v("拒绝策略")]),_._v("建议使用 "),v("code",[_._v("DiscardOldestPolicy")]),_._v(" 或 "),v("code",[_._v("DiscardPolicy")]),_._v("，丢弃最旧任务，优先处理新任务。")])])])]),_._v(" "),v("h4",{attrs:{id:"_3-3-实时响应系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-实时响应系统"}},[_._v("#")]),_._v(" 3.3 "),v("strong",[_._v("实时响应系统")])]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("任务特性")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("需要对请求有快速响应，任务处理时间较短。")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("配置建议")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("核心线程数")]),_._v("和"),v("strong",[_._v("最大线程数")]),_._v("可以相等，设置为 "),v("code",[_._v("CPU 核心数")]),_._v("，确保线程不空闲。")]),_._v(" "),v("li",[v("strong",[_._v("队列容量")]),_._v("设置为 "),v("code",[_._v("0")]),_._v(" 或使用 "),v("code",[_._v("SynchronousQueue")]),_._v("，这样每个任务必须有可用线程来处理。")]),_._v(" "),v("li",[v("strong",[_._v("拒绝策略")]),_._v("可以使用 "),v("code",[_._v("AbortPolicy")]),_._v("，确保系统不会超载，且能够在队列满时快速得到反馈。")])])])]),_._v(" "),v("h3",{attrs:{id:"_4-动态调整线程池配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-动态调整线程池配置"}},[_._v("#")]),_._v(" 4. "),v("strong",[_._v("动态调整线程池配置")])]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("自适应调整")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("在生产环境中，可以考虑使用动态调整线程池配置的策略，根据实际负载调整 "),v("code",[_._v("corePoolSize")]),_._v(" 和 "),v("code",[_._v("maximumPoolSize")]),_._v("。例如，通过监控 CPU 使用率、请求响应时间、任务队列长度等指标，调整线程池配置，以更好地适应波动的流量。")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("监控线程池")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("通过监控线程池的指标（例如，活跃线程数、队列大小、拒绝的任务数）来判断线程池配置是否合适。")]),_._v(" "),v("li",[_._v("可以使用一些开源的 APM（应用性能管理）工具，如 Prometheus 和 Grafana，来监控和分析线程池的各项性能指标，进行必要的调优。")])])])]),_._v(" "),v("h3",{attrs:{id:"_5-jdk-提供的线程池实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-jdk-提供的线程池实现"}},[_._v("#")]),_._v(" 5. "),v("strong",[_._v("JDK 提供的线程池实现")])]),_._v(" "),v("p",[_._v("Java 提供了多种线程池实现，通过 "),v("code",[_._v("Executors")]),_._v(" 工具类可以快速创建：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("FixedThreadPool")]),_._v("：固定大小的线程池，适用于对线程数有固定限制的场景。")]),_._v(" "),v("li",[v("strong",[_._v("CachedThreadPool")]),_._v("：根据需要创建新线程，适合处理大量短期任务的场景，线程空闲时会被回收。")]),_._v(" "),v("li",[v("strong",[_._v("SingleThreadExecutor")]),_._v("：单线程的线程池，适用于需要串行执行任务的场景。")]),_._v(" "),v("li",[v("strong",[_._v("ScheduledThreadPool")]),_._v("：用于周期性执行任务的线程池。")])]),_._v(" "),v("p",[_._v("不过，通常建议自己使用 "),v("code",[_._v("ThreadPoolExecutor")]),_._v(" 来创建线程池，方便灵活配置各种参数，而不是直接使用 "),v("code",[_._v("Executors")]),_._v(" 创建，以更好地控制线程池的行为。\n"),v("strong",[_._v("备注: 是否使用取决于后端代码的是否使用")])]),_._v(" "),v("h3",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),v("p",[_._v("线程池配置的合理性对系统的性能和稳定性有很大的影响。配置线程池时，需要根据系统的特性、任务类型以及硬件资源来制定适当的策略。同时，通过合理的监控和动态调整，可以更好地应对系统的负载变化，从而保持系统的稳定性和高性能。对于每个具体场景，配置需要通过"),v("strong",[_._v("持续测试")]),_._v("与"),v("strong",[_._v("迭代优化")]),_._v("来确定最优方案。")])])}),[],!1,null,null,null);v.default=e.exports}}]);
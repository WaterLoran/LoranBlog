(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{569:function(_,v,t){"use strict";t.r(v);var s=t(2),r=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("确定性能问题是否由 GC（垃圾回收）引起，并给出一些参考标准，可以按照以下步骤系统性地进行：")]),_._v(" "),v("h3",{attrs:{id:"_1-收集-gc-日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-收集-gc-日志"}},[_._v("#")]),_._v(" 1. "),v("strong",[_._v("收集 GC 日志")])]),_._v(" "),v("p",[_._v("要分析 GC 的行为，首先确保 Java 应用启动时启用了 GC 日志记录。你可以通过添加 JVM 启动参数来启用 GC 日志，具体如下：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("Java 8")]),_._v(":"),v("div",{staticClass:"language-sh extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sh"}},[v("code",[v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-Xloggc:gc.log")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-verbose:gc")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-XX:+PrintGCDetails")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-XX:+PrintGCDateStamps")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-XX:+PrintGCApplicationStoppedTime")]),_._v("\n")])])])]),_._v(" "),v("li",[v("strong",[_._v("Java 9 及以上版本")]),_._v(":"),v("div",{staticClass:"language-sh extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sh"}},[v("code",[_._v("-Xlog:gc*:file"),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v("gc.log:time,uptime,level,tags\n")])])])])]),_._v(" "),v("h3",{attrs:{id:"_2-分析-gc-日志的关键指标"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-分析-gc-日志的关键指标"}},[_._v("#")]),_._v(" 2. "),v("strong",[_._v("分析 GC 日志的关键指标")])]),_._v(" "),v("p",[_._v("分析 GC 日志来判断 GC 是否引起了性能问题，主要关注以下几个关键指标：")]),_._v(" "),v("h4",{attrs:{id:"_2-1-gc-频率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-gc-频率"}},[_._v("#")]),_._v(" 2.1 "),v("strong",[_._v("GC 频率")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("Minor GC 频率")]),_._v("：Minor GC 通常发生在新生代满了之后。如果 Minor GC 非常频繁（每隔几秒甚至几百毫秒发生一次），则可能影响应用程序性能。")]),_._v(" "),v("li",[v("strong",[_._v("Full GC 频率")]),_._v("：Full GC 的发生意味着 JVM 停止所有应用线程（STW，Stop-The-World），以回收老年代内存。Full GC 的频率不应过高，如果频繁发生 Full GC，通常是 GC 问题的一个直接表现。")])]),_._v(" "),v("h4",{attrs:{id:"_2-2-gc-停顿时间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-gc-停顿时间"}},[_._v("#")]),_._v(" 2.2 "),v("strong",[_._v("GC 停顿时间")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("Minor GC 停顿时间")]),_._v("：Minor GC 发生时，新生代内存被回收，老年代仍然可以正常工作。通常 Minor GC 的停顿时间应该在 "),v("strong",[_._v("50-200ms")]),_._v(" 以内。如果超过这个时间，频繁的 Minor GC 会导致明显的性能问题。")]),_._v(" "),v("li",[v("strong",[_._v("Full GC 停顿时间")]),_._v("：Full GC 的停顿时间是系统性能的重要指标。"),v("strong",[_._v("理想的 Full GC 停顿时间应保持在 1 秒以内")]),_._v("，但这取决于系统的具体要求。如果 Full GC 时间达到 "),v("strong",[_._v("数秒")]),_._v("甚至 "),v("strong",[_._v("几十秒")]),_._v("，通常会导致系统不可用，用户体验显著下降。")])]),_._v(" "),v("h4",{attrs:{id:"_2-3-内存回收效率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-内存回收效率"}},[_._v("#")]),_._v(" 2.3 "),v("strong",[_._v("内存回收效率")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("内存回收率")]),_._v("：每次 GC 后回收的内存量和速度非常重要。你可以在 GC 日志中看到堆内存使用情况，例如："),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("[Full GC (System.gc()) 1024K->256K(8192K), 0.234567 secs]\n")])])]),v("ul",[v("li",[_._v("上述日志表示 Full GC 发生后，堆内存从 "),v("strong",[_._v("1024K")]),_._v(" 降至 "),v("strong",[_._v("256K")]),_._v("，耗时 "),v("strong",[_._v("0.234 秒")]),_._v("。需要评估回收后的堆内存使用量和频率，如果内存没有明显减少，则可能有内存泄漏。")])])])]),_._v(" "),v("h3",{attrs:{id:"_3-使用监控工具检查-gc-的影响"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用监控工具检查-gc-的影响"}},[_._v("#")]),_._v(" 3. "),v("strong",[_._v("使用监控工具检查 GC 的影响")])]),_._v(" "),v("p",[_._v("使用监控工具可以帮助你更加直观地理解 GC 对系统的影响：")]),_._v(" "),v("h4",{attrs:{id:"_3-1-jvisualvm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-jvisualvm"}},[_._v("#")]),_._v(" 3.1 "),v("strong",[_._v("JVisualVM")])]),_._v(" "),v("ul",[v("li",[_._v("使用 "),v("strong",[_._v("JVisualVM")]),_._v(" 连接到正在运行的 JVM，可以查看堆使用情况、GC 的频率和停顿时间。尤其是 "),v("strong",[_._v("GC 曲线")]),_._v("，你可以观察堆内存的增长和下降趋势。")]),_._v(" "),v("li",[v("strong",[_._v("频繁的 GC 曲线波动")]),_._v("：如果频繁看到“齿轮状”的 GC 曲线，则可能意味着频繁的 GC 对系统造成了影响。")])]),_._v(" "),v("h4",{attrs:{id:"_3-2-jconsole"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-jconsole"}},[_._v("#")]),_._v(" 3.2 "),v("strong",[_._v("JConsole")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("JConsole")]),_._v(" 提供了内存池使用和 GC 相关信息，包括 GC 次数和 GC 时间。")]),_._v(" "),v("li",[_._v("查看老年代（Old Generation）和新生代（Young Generation）的堆使用情况，判断是否存在内存不断增加、无法被回收的情况。")])]),_._v(" "),v("h4",{attrs:{id:"_3-3-第三方监控工具"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-第三方监控工具"}},[_._v("#")]),_._v(" 3.3 "),v("strong",[_._v("第三方监控工具")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("Prometheus + Grafana")]),_._v("、"),v("strong",[_._v("New Relic")]),_._v("、"),v("strong",[_._v("Dynatrace")]),_._v(" 等 APM 工具可以提供更加全面的 JVM 指标，包括内存使用、GC 次数、GC 停顿时间等。")]),_._v(" "),v("li",[_._v("这些工具可以设定告警，当 GC 停顿时间超出合理范围时触发告警，方便及时调整。")])]),_._v(" "),v("h3",{attrs:{id:"_4-堆内存使用的观察"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-堆内存使用的观察"}},[_._v("#")]),_._v(" 4. "),v("strong",[_._v("堆内存使用的观察")])]),_._v(" "),v("p",[_._v("通过工具来观察堆内存的使用情况，检查以下内容：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("新生代频繁满")]),_._v("：如果新生代（Young Generation）频繁满，可能是因为对象创建过于频繁，导致 Minor GC 频率高。")]),_._v(" "),v("li",[v("strong",[_._v("老年代不断增大")]),_._v("：老年代（Old Generation）如果不断增大，并且不容易被回收，可能是因为对象过早地进入老年代，这会导致 Full GC 更频繁地发生。")])]),_._v(" "),v("p",[_._v("可以通过 "),v("strong",[v("code",[_._v("jmap")])]),_._v(" 命令生成内存转储（heap dump），然后使用 "),v("strong",[_._v("Eclipse MAT")]),_._v(" 等工具分析，确定是否有内存泄漏或不必要的对象长期驻留。")]),_._v(" "),v("h3",{attrs:{id:"_5-参考的-gc-性能标准"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-参考的-gc-性能标准"}},[_._v("#")]),_._v(" 5. "),v("strong",[_._v("参考的 GC 性能标准")])]),_._v(" "),v("p",[_._v("在不同场景下对 GC 性能的标准判断可能有所不同，但一些通用的参考标准如下：")]),_._v(" "),v("h4",{attrs:{id:"_5-1-gc-停顿时间标准"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-gc-停顿时间标准"}},[_._v("#")]),_._v(" 5.1 "),v("strong",[_._v("GC 停顿时间标准")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("Minor GC 停顿")]),_._v("：通常需要保持在 "),v("strong",[_._v("50-200ms")]),_._v(" 以内。如果应用是延迟敏感型的，如实时交易系统，甚至要求低于 "),v("strong",[_._v("50ms")]),_._v("。")]),_._v(" "),v("li",[v("strong",[_._v("Full GC 停顿")]),_._v("：应尽量保持在 "),v("strong",[_._v("1 秒以内")]),_._v("。如果 Full GC 时间在 "),v("strong",[_._v("1 秒以上")]),_._v("，可能需要优化 GC 策略或调整堆内存配置。")])]),_._v(" "),v("h4",{attrs:{id:"_5-2-gc-频率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-gc-频率"}},[_._v("#")]),_._v(" 5.2 "),v("strong",[_._v("GC 频率")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("Minor GC")]),_._v("：频率过高（例如每秒多次）通常意味着新生代内存不足。一般情况下，Minor GC 每隔几秒到几十秒发生一次是较为正常的。")]),_._v(" "),v("li",[v("strong",[_._v("Full GC")]),_._v("：理想情况下，Full GC 应尽可能少发生，通常建议每小时最多几次。如果 Full GC 频率为每分钟甚至更频繁，则需要进行内存调优。")])]),_._v(" "),v("h4",{attrs:{id:"_5-3-内存回收效率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-内存回收效率"}},[_._v("#")]),_._v(" 5.3 "),v("strong",[_._v("内存回收效率")])]),_._v(" "),v("ul",[v("li",[_._v("每次 "),v("strong",[_._v("Minor GC")]),_._v(" 后，"),v("strong",[_._v("新生代")]),_._v("内存应该大幅减少，说明短生命周期对象被及时清理。")]),_._v(" "),v("li",[_._v("每次 "),v("strong",[_._v("Full GC")]),_._v(" 后，"),v("strong",[_._v("老年代")]),_._v("应该保持在一个稳定的水平。如果每次 Full GC 结束后，老年代的内存使用量仍然较高（接近上限），说明内存回收效率低，可能有内存泄漏或需要增加老年代大小。")])]),_._v(" "),v("h3",{attrs:{id:"_6-具体操作和判断过程总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-具体操作和判断过程总结"}},[_._v("#")]),_._v(" 6. "),v("strong",[_._v("具体操作和判断过程总结")])]),_._v(" "),v("p",[_._v("以下是具体的步骤来确定 GC 是否引起了性能问题的流程：")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("收集 GC 日志")]),_._v("：添加 GC 日志参数，运行应用并收集 GC 日志文件。")]),_._v(" "),v("li",[v("strong",[_._v("分析 GC 日志")]),_._v("：查看 GC 日志中的停顿时间、GC 类型（Minor GC 还是 Full GC）、内存回收的情况等。")]),_._v(" "),v("li",[v("strong",[_._v("使用监控工具")]),_._v("：通过 JVisualVM、JConsole 或 APM 工具查看堆内存曲线、GC 次数和停顿时间，判断是否存在过于频繁或过长时间的 GC。")]),_._v(" "),v("li",[v("strong",[_._v("堆内存分析")]),_._v("：使用 "),v("code",[_._v("jmap")]),_._v(" 获取堆内存转储文件，利用工具（如 Eclipse MAT）分析内存中的对象分布，确定是否有不必要的对象没有被回收。")]),_._v(" "),v("li",[v("strong",[_._v("参考性能标准")]),_._v("：将 GC 停顿时间、GC 频率与参考标准对比。如果发现 GC 频率过高或停顿时间过长，就需要优化 GC 配置。")])]),_._v(" "),v("h3",{attrs:{id:"_7-可能的优化措施"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-可能的优化措施"}},[_._v("#")]),_._v(" 7. "),v("strong",[_._v("可能的优化措施")])]),_._v(" "),v("p",[_._v("如果确认 GC 是引起性能问题的原因，可以考虑以下优化措施：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("增大堆内存大小")]),_._v("：增加堆内存的大小可以减少 GC 的频率。例如，"),v("code",[_._v("-Xmx")]),_._v(" 和 "),v("code",[_._v("-Xms")]),_._v(" 可以适当调高。")]),_._v(" "),v("li",[v("strong",[_._v("调整新生代大小")]),_._v("：增加新生代的大小，减少对象过早进入老年代。")]),_._v(" "),v("li",[v("strong",[_._v("选择合适的 GC 策略")]),_._v("：\n"),v("ul",[v("li",[v("strong",[_._v("G1 GC")]),_._v("：适合低停顿时间的需求，使用 "),v("code",[_._v("-XX:+UseG1GC")]),_._v("。")]),_._v(" "),v("li",[v("strong",[_._v("ZGC 或 Shenandoah")]),_._v("：对于要求非常低暂停时间的应用，可以考虑使用 ZGC（Java 11 及以上）或 Shenandoah（OpenJDK）。")])])]),_._v(" "),v("li",[v("strong",[_._v("减少对象创建频率")]),_._v("：通过代码优化，减少短生命周期对象的创建数量，使用对象池来复用对象。")])]),_._v(" "),v("h3",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),v("p",[_._v("确定性能问题是否由 GC 引起的主要步骤包括："),v("strong",[_._v("收集 GC 日志")]),_._v("、"),v("strong",[_._v("分析日志中的 GC 停顿时间和频率")]),_._v("、"),v("strong",[_._v("使用监控工具观察 GC 活动")]),_._v("、"),v("strong",[_._v("通过堆内存分析判断是否存在内存泄漏")]),_._v("，并且对比相应的 "),v("strong",[_._v("性能标准")]),_._v("（如 GC 停顿时间和频率）。通过这些手段，你可以系统地判断 GC 是否是造成性能问题的原因，并根据结果采取相应的优化措施。")])])}),[],!1,null,null,null);v.default=r.exports}}]);